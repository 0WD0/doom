#+begin_src emacs-lisp
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-
#+end_src
这个词法作用域配置是必要的

这是一些在配置 doom 时可能有帮助的额外的 函数/宏
 - `load!' for loading external *.el files relative to this one
 - `use-package!' for configuring packages
 - `after!' for running code after a package has loaded
 - `add-load-path!' for adding directories to the `load-path', relative to
   this file. Emacs searches the `load-path' when you load packages with
   `require' or `use-package'.
 - `map!' for binding new keys

Whenever you reconfigure a package, make sure to wrap your config in an
`after!' block, otherwise Doom's defaults may override your settings. E.g.

  (after! PACKAGE
    (setq x y))

The exceptions to this rule:

  - Setting file/directory variables (like `org-directory')
  - Setting variables which explicitly tell you to set them before their
    package is loaded (see 'C-h v VARIABLE' to look up their documentation).
  - Setting doom variables (which start with 'doom-' or '+').

To get information about any of these functions/macros, move the cursor over the highlighted symbol at press 'K' (non-evil users must press 'C-c c k').
This will open documentation for it, including demos of how they are used. Alternatively, use `C-h o' to look up a symbol (functions, variables, faces, etc).
You can also try 'gd' (or 'C-c c d') to jump to their definition and see how they are implemented.

* packages.el
#+begin_src emacs-lisp :tangle packages.el
;;; $DOOMDIR/packages.el -*- no-byte-compile: t; -*-
#+end_src
使用 Doom 安装软件包时，必须在此处声明并运行命令行中的 'doom sync'，然后重启 Emacs 才能让更改生效 -- 或者

从 MELPA、ELPA 或 emacsmirror 安装 SOME-PACKAGE：
~(package! some-package)~

若要从远程 Git 仓库直接安装软件包，您需要指定一个 ~:recipe~ （配方）
关于 ~:recipe~ 接受的格式说明请参见： https://github.com/radian-software/straight.el#the-recipe-format
(package! another-package
  :recipe (:host github :repo "username/repo"))

当您要安装的包中没有 PACKAGENAME.el 文件，或该文件位于仓库子目录中时，您需要在 `:recipe' 中指定 `:files'：
(package! this-package
  :recipe (:host github :repo "username/repo"
           :files ("some-file.el" "src/lisp/*.el")))

如果想要禁用 Doom 自带的包，可以在此处使用 ~:disable~ 属性：
(package! builtin-package :disable t)

您可以无需指定 ~:recipe~ 的所有属性，就覆盖内置包的配方。这些设置将继承其他部分的配方信息（来自 Doom 或 MELPA/ELPA/Emacsmirror）：
(package! builtin-package :recipe (:nonrecursive t))
(package! builtin-package-2 :recipe (:repo "myfork/package"))

使用 ~:branch~ 指定从特定分支或标签安装包（某些默认分支不是 'master' 的包需要此项配置，因为当前包管理器无法处理；参见 radian-software/straight.el#279）：
(package! builtin-package :recipe (:branch "develop"))

使用 ~:pin~ 指定特定提交哈希来安装包：
(package! builtin-package :pin "1a2b3c4d5e")

Doom 的所有包都默认绑定到特定提交哈希，并在版本更新时更新。使用 `unpin!' 宏可以解除单个包的绑定...
(unpin! pinned-package)
...或多个包
(unpin! pinned-package another-pinned-package)
...或者 *全部* 包（不推荐，很可能导致错误）
(unpin! t)

* Misc

是否解析符号链接
#+begin_src emacs-lisp
(setq find-file-visit-truename t)
#+end_src

缩进风格
#+begin_src emacs-lisp
(setq indent-tabs-mode nil)
(setq tab-width 4)
#+end_src

** bibilo 模块设置
#+begin_src emacs-lisp
(setq! citar-bibliography '("/home/disk/Books/mybib.bib")
       citar-open-entry-function 'citar-open-entry-in-zotero)

(map!
 :map org-mode-map
 :localleader
 (:prefix ("C" . "Citar")
          (:prefix ("i" . "insert")
           :desc "Insert reference" "r" #'citar-insert-reference
           :desc "Insert citation" "c" #'citar-insert-citation
           :desc "Insert bibtex" "b" #'citar-insert-bibtex
           :desc "Insert keys" "k" #'citar-insert-keys
           )
          (:prefix ("o" . "open")
           :desc "Open citar" "o" #'citar-open
           :desc "Open files" "f" #'citar-open-files
           :desc "Open notes" "n" #'citar-open-notes
           :desc "Open note directly" "N" #'citar-open-note
           :desc "Open links" "l" #'citar-open-links
           :desc "Open entry in zotero" "e" #'citar-open-entry
           )
          ))

(map! :map org-mode-map
      :localleader
      :prefix ("m" . "org-roam")
      "c" #'citar-org-roam-open-current-refs)
;; 下面是 citar-map 里的默认绑定，我不知道这个 keymap 原来是用在哪里的

;; RET citar-run-default-action
;; a   citar-add-file-to-library
;; r   citar-copy-reference

;; R   citar-insert-reference
;; b   citar-insert-bibtex
;; c   citar-insert-citation
;; k   citar-insert-keys
;; o   citar-open
;; e   citar-open-entry
;; f   citar-open-files
;; l   citar-open-links
;; n   citar-open-notes

;; 看源码看到的函数
;; citar-open-note
;;
#+end_src


** indent-bars

如果 =indent-bars-starting-column= 为 0，会在 org-mode 的 latex 片段的前面一个空格显示竖线！

#+begin_src emacs-lisp
(after! indent-bars
  (setq indent-bars-treesit-support t
        indent-bars-starting-column nil))
#+end_src

** consult.el

live preview

来自官方文档
#+begin_src emacs-lisp
(after! consult
  (consult-customize
   consult-ripgrep consult-git-grep consult-grep consult-man
   consult-bookmark consult-recent-file consult-xref
   consult--source-bookmark consult--source-file-register
   consult--source-recent-file consult--source-project-recent-file
   ;; my/command-wrapping-consult    ;; disable auto previews inside my command
   :preview-key '(:debounce 0.4 any) ;; Option 1: Delay preview
   ;; :preview-key "M-."             ;; Option 2: Manual preview
   ))
#+end_src

** nov.el

epub 支持

#+begin_src emacs-lisp :tangle packages.el
(package! nov)
#+end_src

#+begin_src emacs-lisp
(use-package! nov
  :mode ("\\.epub\\'" . nov-mode)
  :config
  (setq nov-save-place-file (concat doom-cache-dir "nov-places")))
#+end_src

** telega.el

telegram client for emacs

#+begin_src emacs-lisp :tangle packages.el
;; (package! company)
(package! telega)
#+end_src

#+begin_src emacs-lisp
(setq! telega-server-libs-prefix "/usr")
(use-package! telega
  :commands (telega)
  :defer t
  :init
  (unless (display-graphic-p) (setq telega-use-images nil))
  :config
  (define-key global-map (kbd "C-c t") telega-prefix-map)
  ;; (setq telega-proxies
  ;;       (list '(:server "127.0.0.1" :port 1086 :enable t
  ;;               :type (:@type "proxyTypeSocks5"))))
  (set-popup-rule! "^\\*Telega Root"
    :side 'right :size 100 :quit nil :modeline t)
  (set-popup-rule! "^◀\\(\\[\\|<\\|{\\).*\\(\\]\\|>\\|}\\)"
    :side 'right :size 100 :quit nil :modeline t)
  (telega-mode-line-mode 1))
#+end_src

** IRC config

#+begin_src emacs-lisp :tangle no
(setq! circe-network-options
      '(("Libera Chat"
         :tls t
         :nick "oWDo"
         :sasl-username "my-nick"
         :sasl-password "my-password"
         :channels ("#emacs-circe")
         )))
#+end_src

** solar.el

#+begin_src emacs-lisp
(setq! calendar-latitude 30.29365
       calendar-longitude 120.16142)
#+end_src

* 基础设置

** Theme
There are two ways to load a theme. Both assume the theme is installed and
available. You can either set `doom-theme' or manually load a theme with the
`load-theme' function.

#+begin_src emacs-lisp :tangle packages.el
(package! catppuccin-theme)
#+end_src

#+begin_src emacs-lisp
(setq doom-theme 'catppuccin)
(setq catppuccin-flavor 'frappe)
#+end_src

** Fonts
Doom exposes five (optional) variables for controlling fonts in Doom:

- `doom-font' -- the primary font to use
- `doom-variable-pitch-font' -- a non-monospace font (where applicable)
- `doom-big-font' -- used for `doom-big-font-mode'; use this for
  presentations or streaming.
- `doom-symbol-font' -- for symbols
- `doom-serif-font' -- for the `fixed-pitch-serif' face

See 'C-h v doom-font' for documentation and more examples of what they
accept. For example:


If you or Emacs can't find your font, use 'M-x describe-font' to look them
up, `M-x eval-region' to execute elisp code, and 'M-x doom/reload-font' to
refresh your font settings. If Emacs still can't find your font, it likely
wasn't installed correctly. Font issues are rarely Doom issues!
#+begin_src emacs-lisp
;; 日常阅读使用 Fira Code，代码使用 Fira Code
(setq doom-font (font-spec :family "Fira Code" :size 24 :weight 'normal)
      doom-variable-pitch-font (font-spec :family "Fira Code" :size 24)
      doom-big-font (font-spec :family "Fira Code" :size 36)
      doom-serif-font (font-spec :family "Fira Sans" :size 24))

;; 中文字体配置 - 使用最佳实践
(defun my-cjk-font ()
  "Set CJK font for mixed Chinese-English display"
  (dolist (charset '(kana han cjk-misc symbol bopomofo))
    (set-fontset-font t charset (font-spec :family "LXGW WenKai"))))

(add-hook 'after-setting-font-hook #'my-cjk-font)

;; 设定所有英文斜体使用 Hack Nerd Font
(custom-set-faces!
 '(italic :family "Hack Nerd Font" :slant italic))
#+end_src

** Line numbers

#+begin_src emacs-lisp
(setq! display-line-numbers-type t)
#+end_src

** Line Wrap

[[https://www.emacswiki.org/emacs/LineWrap][EmacsWiki: Line Wrap]]
[[https://emacs-china.org/t/topic/2616/34][中英文混排时候的自动折行？ - #34，来自 ltylty - Emacs-general - Emacs China]]

*** CJK 字符换行支持

#+begin_src emacs-lisp
(setq! word-wrap-by-category t)
(modify-category-entry '(45 . 47) ?|)  ;; ASCII 45-47, i.e. ",-/"
(modify-category-entry 58 ?|)          ;; ASCII 58, i.e. ":"
#+end_src

* UI

** neoscoll

我自己写的平滑滚动插件

#+begin_src emacs-lisp
(setq! neoscroll-line-step 4
       neoscroll-easing 'linear
       ;; neoscroll-line-duration 0.01
       ;; neoscroll-page-duration 0.10
       ;; neoscroll-scroll-duration 0.10
       )
#+end_src

* org-mode

org 是一个强大的笔记和文档管理工具，Doom Emacs 提供了许多配置选项来增强 org-mode 的功能。

#+begin_src emacs-lisp :tangle packages.el
(unpin! org-roam)
#+end_src

#+begin_src emacs-lisp
(add-hook 'org-mode-hook (lambda () (setq-local tab-width 8)))
(setq! org-directory "~/org"
      org-roam-directory "~/org/roam"
      org-roam-completion-everywhere t
      org-agenda-files (directory-files-recursively "~/org/" "\\.org$")
      org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-id-link-consider-parent-id t
      ;; org-confirm-babel-evaluate nil
      org-edit-src-content-indentation 0
      )
#+end_src

** UI

*** My +pretty

#+begin_src emacs-lisp :tangle packages.el
(package! org-appear :pin "32ee50f8fdfa449bbc235617549c1bccb503cb09")
(package! org-modern :pin "1723689710715da9134e62ae7e6d41891031813c")
(package! org-modern-indent
  :recipe (:host github :repo "jdtsmith/org-modern-indent"))
#+end_src

#+begin_src emacs-lisp
(after! org
  (setq org-highlight-latex-and-related '(native script entities)
        org-hide-emphasis-markers t
        org-pretty-entities nil
        org-appear-autosubmarkers t
        org-appear-inside-latex t
        org-appear-autolinks 'just-brackets
        org-appear-autoentities t))

(use-package! org-appear
  :hook (org-mode . org-appear-mode))

(add-hook 'org-mode-hook #'org-modern-indent-mode 90)

(use-package! org-modern
  :hook (org-mode . org-modern-mode)
  :hook (org-agenda-finalize . org-modern-agenda)
  :init
  (setq org-modern-todo nil
        org-modern-list '((43 . "◦") (45 . "•") (42 . "–")))

  :config
  ;; HACK: The default unicode symbol for checked boxes often turn out much
  ;;   larger than the others, so I swap it out with one that's more likely to
  ;;   be consistent.
  (setf (alist-get ?X org-modern-checkbox) #("□x" 0 2 (composition ((2)))))

  ;; HACK: If `org-indent-mode' is active, org-modern's default of hiding
  ;;   leading stars makes sub-headings look too sunken into the left margin.
  ;;   Those stars are already "hidden" by `org-hide-leading-stars' anyway, so
  ;;   rely on just that.
  (add-hook! 'org-modern-mode-hook
    (defun +org-modern-show-hidden-stars-in-indent-mode-h ()
      (when (bound-and-true-p org-indent-mode)
        (setq-local org-modern-hide-stars nil))))

  ;; Carry over the default values of `org-todo-keyword-faces', `org-tag-faces',
  ;; and `org-priority-faces' as reasonably as possible, but only if the user
  ;; hasn't already modified them.
  (letf! (defun new-spec (spec)
           (if (or (facep (cdr spec))
                   (not (keywordp (car-safe (cdr spec)))))
               `(:inherit ,(cdr spec))
             (cdr spec)))
    (unless org-modern-tag-faces
      (dolist (spec org-tag-faces)
        (add-to-list 'org-modern-tag-faces `(,(car spec) :inverse-video t ,@(new-spec spec)))))
    (unless org-modern-todo-faces
      (dolist (spec org-todo-keyword-faces)
        (add-to-list 'org-modern-todo-faces `(,(car spec) :inverse-video t ,@(new-spec spec)))))
    (unless org-modern-priority-faces
      (dolist (spec org-priority-faces)
        (add-to-list 'org-modern-priority-faces `(,(car spec) :inverse-video t ,@(new-spec spec)))))))
#+end_src

*** org-mode 标题颜色设置

#+begin_src emacs-lisp
(custom-set-faces!
   '(org-level-1 :foreground "#c6d0f5" :weight bold :height 1.3)      ; 纯文本色，最亮
   '(org-level-2 :foreground "#b5bfe2" :weight semi-bold :height 1.2) ; 稍微暗一点
   '(org-level-3 :foreground "#a4aed0" :weight semi-bold :height 1.1) ; 更暗
   '(org-level-4 :foreground "#939dbd" :weight normal)                ; 继续变暗
   '(org-level-5 :foreground "#828cab" :weight normal)                ; 更暗
   '(org-level-6 :foreground "#717b98" :weight normal)                ; 再暗
   '(org-level-7 :foreground "#606a86" :weight normal)                ; 很暗
   '(org-level-8 :foreground "#4f5973" :weight normal))               ; 最暗
#+end_src

*** org-mode 代码块颜色配置

#+begin_src emacs-lisp
;; 自定义 org-mode 代码块颜色 - 与 catppuccin frappe 主题协调
(after! org
  (custom-set-faces!
   ;; 代码块开始/结束标记
   '(org-block-begin-line :background "#232634" :foreground "#737994" :extend t)
   '(org-block-end-line :background "#232634" :foreground "#737994" :extend t)
   ;; 行内代码颜色
   '(org-block :foreground "#c6d0f5" :extend t)))
#+end_src

*** 对 org-mode 禁用 indent-bars

#+begin_src emacs-lisp
(add-hook 'org-mode-hook
          (lambda ()
            (when (bound-and-true-p indent-bars-mode)
              (indent-bars-mode -1))))
#+end_src

** org-roam 增强

*** 快速打开 =:ROAM_REFS:=

一般来说不会有很多 ROAM_REFS

竟然这么好实现

之后可以和 citar 集成一下

#+begin_src emacs-lisp
(defun my/open-roam-refs ()
  "Open one of the ROAM_REFS links for current entry."
  (interactive)
  (let ((refs (org-entry-get nil "ROAM_REFS")))
    (when refs
      (let* ((links (split-string refs " "))
             (link (completing-read "Open link: " links)))
        (browse-url link)))))

(map! :map org-mode-map
      :localleader
      :prefix ("m" . "org-roam")
      "b" #'my/open-roam-refs)
#+end_src


*** 算法竞赛模板导出工具

**** 关键tag

#+begin_src emacs-lisp
(defvar my/org-roam-export-tag nil)
(defvar my/org-roam-export-tags '("CP" "CF" "contest"))
#+end_src

之后需要看看怎么扩展到多个 tag
暂时先搞单个的实现

**** 提取主节点
我这其实和 [[id:8e646f0b-aa8e-470b-9dd9-d70b8693dd3c][lazyblorg]] 干了差不多的事情，但是它捕捉的是 blog 这个 tag
然后让每个子树形成一篇博客，导出成 html
我这里却是平铺导出成 latex 加上页码链接

#+begin_src emacs-lisp
(defun my/org-roam-nodes-with-tag (tag &optional inheritp)
  "Return org-roam nodes where TAG is locally defined (non-inherited)."
  ;; (require 'org-roam)
  (let* ((rows (org-roam-db-query
                [:select [nodes:file nodes:pos nodes:id]
                 :from nodes
                 :inner :join tags :on (= nodes:id tags:node_id)
                 :where (= tags:tag $s1)]
                tag))
         (result '()))
    (if inheritp
        (dolist (row rows result)
          (push (org-roam-node-from-id (nth 2 row)) result))
      (dolist (row rows result)
        (let ((file (nth 0 row))
              (pos  (nth 1 row))
              node)
          (with-current-buffer (find-file-noselect file)
            (save-excursion
              (goto-char pos)
              (setq node (org-roam-node-at-point t))
              (setq local-tags
                    (if (eq pos 1)
                        org-file-tags
                      (org-get-tags nil t)))
              (when (member tag local-tags)
                (push node result))))))
      result)))
#+end_src

**** 拉入节点子树
先通过 =my/org-roam-nodes-with-tag= 得到所有需要拉入的不重复的子树

拉入的时候需要统一标题层级

需要统一文件节点的形式

需要借鉴 [[help:org-roam-refile]]
其实并不复杂，实现好了

#+begin_src emacs-lisp
(defun my/org-roam-extract-subtree (node)
  (let ((file (org-roam-node-file node))
        (pos  (org-roam-node-point node)))
    (with-temp-buffer
      (org-mode)
      (insert-file-contents file)
      (goto-char pos)
      (when (org-before-first-heading-p)
        (org-roam-demote-entire-buffer))
      (org-copy-subtree 1 nil t))))
#+end_src

然后可以用 [[help:org-paste-subtree]] 进行粘贴

**** 重排序
然后根据某些规则安排顺序
可以从 org-roam 中直接导出这个 tag 的所有节点，来重新得到各个节点在这个文件中的锚点（大概可以通过查询 id 得到）

**** 添加反向链接
反向链接要需显示父标题链（文件标题+olp+节点标题）
其实子树节点也可以显示一下副标题链？

其实可以 join 一下同时查 id 和 title

[[help:org-id-find-id-in-file]] 可以用这个函数来得到 id 位置
应该很好用

#+begin_src emacs-lisp :tangle no
(defun my/org-roam-backlinks-of-id-old (id)
  "Return list of (SRC-ID TITLE)."
  (let* ((rows (org-roam-db-query
                [:select [source]
                 :from links
                 :where (and (= dest $s1) (= type "id"))]
                id))
         res)
    (dolist (row rows)
      (let* ((id (car row))
             (title (org-roam-node-title (org-roam-node-from-id id))))
        (message "%s" id)
        (push (list id title) res)))
    (nreverse res)))
#+end_src

#+begin_src emacs-lisp
(defun my/org-roam-backlinks-of-id (id)
  "Return list of (SRC-ID TITLE)."
  (let* ((rows (org-roam-db-query
                [:select [links:source]
                 :from links
                 :inner :join tags :on (= links:source tags:node_id)
                 :where (and (= links:dest $s1) (= links:type "id") (= tags:tag $s2))]
                id my/org-roam-export-tag))
         res)
    (dolist (row rows)
      (let* ((id (car row))
             (title (org-roam-node-title (org-roam-node-from-id id))))
        (push (list id title) res)))
    (nreverse res)))
#+end_src

#+begin_src emacs-lisp
(defun my/org-roam-append-to-node-end (id file content)
  "在指定节点的末尾（而非文件末尾）追加内容"
  (save-excursion
    (goto-char (cdr (org-id-find-id-in-file id file)))
    ;; 移动到节点内容的末尾，但在下一个同级标题之前
    (goto-char (org-entry-end-position))
    ;; 向前移动一个字符，确保在节点内容末尾
    (backward-char 1)
    (end-of-line)
    (insert "\n" content)))
#+end_src

#+begin_src emacs-lisp
(defun my/org-insert-backlinks-section (id file)
  (let ((bl (my/org-roam-backlinks-of-id id)))
    (when bl
      (let ((content "\n- Backlinks\n"))
        (dolist (pair bl)
          (setq content (concat content (format "  - [[id:%s][%s]]\n" (car pair) (cadr pair)))))
        (message "Id: %s backlinks: %s" id content)
        (my/org-roam-append-to-node-end id file content)))))
#+end_src

**** 导出页码
最后支持一下页码导出功能
应该就是用 \pageref{sec:chapter_one} 这样的东西
但是，我怎么在导出前知道他生成的 lable ？ 能不能修改链接导出的方式？

[[help:org-latex-link]] 理论上可以advice这个函数

我不确定能不能拆成多个文件，ox-latex 似乎不支持这种功能

**** 主要导出函数

#+begin_src emacs-lisp
;; -- org-roam: export top-tagged subtrees to PDF (headline hierarchy parent definition) --
;; (require 'org)
;; (require 'org-roam)
;; (require 'org-element)
;; (require 'seq)
;; (require 'cl-lib)
(setq! org-latex-pdf-process
       '("latexmk -pdflatex=xelatex -pdf -interaction=nonstopmode -output-directory=%o %f"))

(defun my/org-roam-export-top-tagged-subtrees-to-pdf (tag &optional outfile)
  "Export all top-tagged org-roam headlines (by headline hierarchy) into a single PDF.
Inserts each subtree, adds backlinks, TOC, and uses xelatex+ctex for CJK."
  (interactive "sTag: ")
  (org-roam-db-sync)

  (setq my/org-roam-export-tag tag)
  (let ((file-name (make-temp-file (format "roam-export-%s-" tag)))
        (top-nodes (my/org-roam-nodes-with-tag tag))
        (all-nodes (my/org-roam-nodes-with-tag tag t)))
    (with-temp-file file-name
      (org-mode)
      ;; Export header: Chinese + hyperref + TOC + numbered headings
      (insert "#+title: Roam Export\n")
      (insert "#+options: toc:t num:t\n")
      (insert "#+latex_header: \\usepackage[UTF8]{ctex}\n")
      (insert "#+latex_compiler: xelatex\n\n")
      (dolist (n top-nodes)
          (my/org-roam-extract-subtree n)
          (org-paste-subtree 2))

      (write-file file-name)

      (dolist (n all-nodes)
        (let ((id (org-roam-node-id n)))
          (my/org-insert-backlinks-section id file-name)))

      ;; Export to PDF
      (let ((outfile (or outfile (expand-file-name (format "roam-%s.pdf" tag) default-directory))))
        (org-latex-export-to-pdf)
        (message "Exported PDF for tag %s. Buffer: %s" tag (buffer-name))))))
#+end_src

**** 快捷键绑定
#+begin_src emacs-lisp
(map! :leader
      :desc "Roam export top-tagged subtrees to PDF"
      "n r e" #'my/org-roam-export-top-tagged-subtrees-to-pdf)
#+end_src

** HOLD 自动为 =:chat:= 标签添加 folded VISIBILITY

还未能正常工作

说实话可以用 =:ARCHIVE:= 标签平替

#+begin_src emacs-lisp :tangle no
(after! org
  (defun my/org-auto-fold-chat-headings ()
    "Automatically add VISIBILITY: folded property to headings with :chat: tag."
    (save-excursion
      (save-restriction
        (widen)
        (goto-char (point-min))
        (while (re-search-forward "^\\*+ " nil t)
          (when (org-at-heading-p)
            (let ((tags (org-get-tags nil t)))
              (when (member "chat" tags)
                (unless (string= (org-entry-get nil "VISIBILITY") "folded")
                  (org-entry-put nil "VISIBILITY" "folded")))))))))

  (defun my/org-add-visibility-on-tag-change ()
    "Add folded VISIBILITY when :chat: tag is added."
    (when (org-at-heading-p)
      (let ((tags (org-get-tags nil t)))
        (when (member "chat" tags)
          (unless (string= (org-entry-get nil "VISIBILITY") "folded")
            (org-entry-put nil "VISIBILITY" "folded")
            (org-cycle-hide-property-drawers 'overview))))))

  ;; 当标签改变时检查
  (add-hook 'org-after-tags-change-hook #'my/org-add-visibility-on-tag-change)
  
  ;; 打开文件时扫描整个文件
  (add-hook 'org-mode-hook 
            (lambda ()
              (run-with-idle-timer 0.1 nil #'my/org-auto-fold-chat-headings)))
  
  ;; 保存文件前自动添加
  (add-hook 'before-save-hook 
            (lambda ()
              (when (eq major-mode 'org-mode)
                (my/org-auto-fold-chat-headings)))))
#+end_src

** org-babel 配置

*** 让 lsp-mode 在 org-src-mode 下工作

[[https://tecosaur.github.io/emacs-config/config.html#lsp-support-src][tecosaur's Doom Emacs Configuration]]
在这里抄的

#+begin_src emacs-lisp
(cl-defmacro lsp-org-babel-enable (lang)
  "Support LANG in org source code block."
  (setq centaur-lsp 'lsp-mode)
  (cl-check-type lang string)
  (let* ((edit-pre (intern (format "org-babel-edit-prep:%s" lang)))
         (intern-pre (intern (format "lsp--%s" (symbol-name edit-pre)))))
    `(progn
       (defun ,intern-pre (info)
         (let ((file-name (->> info caddr (alist-get :file))))
           (unless file-name
             (setq file-name (make-temp-file "babel-lsp-")))
           (setq buffer-file-name file-name)
           (lsp-deferred)))
       (put ',intern-pre 'function-documentation
            (format "Enable lsp-mode in the buffer of org source block (%s)."
                    (upcase ,lang)))
       (if (fboundp ',edit-pre)
           (advice-add ',edit-pre :after ',intern-pre)
         (progn
           (defun ,edit-pre (info)
             (,intern-pre info))
           (put ',edit-pre 'function-documentation
                (format "Prepare local buffer environment for org source block (%s)."
                        (upcase ,lang))))))))

(defvar org-babel-lang-list
  '("go" "python" "ipython" "bash" "sh" "cpp"))

(dolist (lang org-babel-lang-list)
  (eval `(lsp-org-babel-enable ,lang)))

#+end_src

*** ob-C-stdin

[[https://github.com/cxa/ob-C-stdin/tree/main][GitHub]]
让 C/C++ 支持 ~:stdin <element-name>~

很好用，可以直接在笔记里跑样例了

#+begin_src emacs-lisp
(after! ob-C
  (defun org-babel-C-execute/filter-args (args)
    (when-let* ((params (cadr args))
                (stdin (cdr (assoc :stdin params)))
                (res (org-babel-ref-resolve stdin))
                (stdin (org-babel-temp-file "c-stdin-")))
      (with-temp-file stdin (insert res))
      (let* ((cmdline (assoc :cmdline params))
             (cmdline-val (or (cdr cmdline) "")))
        (when cmdline (setq params (delq cmdline params)))
        (setq params
              (cons (cons :cmdline (concat cmdline-val " <" stdin))
                    params))
        (setf (cadr args) params)))
    args)

  (with-eval-after-load 'ob-C
    (advice-add 'org-babel-C-execute :filter-args
                #'org-babel-C-execute/filter-args)))
#+end_src

** org-latex-preview

*** 添加 LaTeX 包

貌似没有区别

#+begin_src emacs-lisp :tangle no
(after! org
  (dolist (pkg '("amsmath" "amssymb" "mathtools" "mathrsfs"))
    (add-to-list 'org-latex-packages-alist `("" ,pkg t))))
#+end_src

*** LaTeX 预览渲染进程设置

#+begin_src emacs-lisp
(setq org-preview-latex-default-process 'dvisvgm)
#+end_src

*** Highlight

[[https://stackoverflow.com/questions/69474043/emacs-org-mode-background-color-of-latex-fragments-with-org-highlight-latex-a][Emacs org mode: background color of latex fragments (with `org-highlight-latex-and-related`) : which variable to change?]]

单独设置行内 LaTeX 块的背景颜色

#+begin_src emacs-lisp
(after! org-src
  (add-to-list 'org-src-block-faces
               '("latex" (:inherit default :extend t)))
  )
#+end_src

*** evil-mode

不知道有什么用
#+begin_src emacs-lisp :tangle no
(add-hook! 'org-src-mode-hook
  (when (string= major-mode "latex-mode")
    (evil-tex-mode 1)))
#+end_src

*** LaTeX 预览图像缩放
:PROPERTIES:
:CUSTOM_ID: latex-resize
:END:

[[https://karthinks.com/software/scaling-latex-previews-in-emacs/][Scaling Latex previews in Emacs | Karthinks]] 这篇文章和评论区帮了大忙了

#+begin_src emacs-lisp
(defun my/text-scale-adjust-latex-previews ()
  "Adjust the size of latex preview fragments when changing the buffer's text scale."
  (pcase major-mode
    ('latex-mode
     (dolist (ov (overlays-in (point-min) (point-max)))
       (if (eq (overlay-get ov 'category)
               'preview-overlay)
           (my/text-scale--resize-fragment ov))))
    ('org-mode
     (dolist (ov (overlays-in (point-min) (point-max)))
       (if (eq (overlay-get ov 'org-overlay-type)
               'org-latex-overlay)
           (my/text-scale--resize-fragment ov))))))

(defun my/text-scale--resize-fragment (ov)
  ;; 直接根据当前文本缩放设置图像的 :scale
  ;; 由于 org-format-latex-options 的 :scale 固定为 1.0，这里直接设置最终缩放
  (let* ((base-scale 1.0)  ; 基础缩放比例，可以调整
         (step (if (boundp 'text-scale-mode-step) text-scale-mode-step 1.2))
         (amount (if (boundp 'text-scale-mode-amount) text-scale-mode-amount 0))
         (factor (expt step amount))
         (new-scale (* base-scale factor)))
    ;; 更新display的scale
    (overlay-put
     ov 'display
     (cons 'image
           (plist-put
            (cdr (overlay-get ov 'display))
            :scale new-scale)))))

(add-hook 'text-scale-mode-hook #'my/text-scale-adjust-latex-previews)

;; 在LaTeX预览渲染后立即应用正确的缩放
(defun my/latex-preview-post-render (&rest _)
  "在LaTeX预览渲染后应用当前的文本缩放"
  (when (eq major-mode 'org-mode)
    (my/text-scale-adjust-latex-previews)))

;; 使用advice拦截LaTeX预览渲染函数
(after! org
  (advice-add 'org-latex-preview :after #'my/latex-preview-post-render))
#+end_src

**** TODO 在标题处按 RET 时也会 toggle latex 预览，此时预览跳出的大小没有被正确设置！
**** TODO 现在的设置没有随字体大小变化而变化，在字体调大之后预览会出现占不满行高的情况

** typst 集成

#+begin_src emacs-lisp
(defvar org-typst-scale-ratio 180)
(defvar org-typst-debug nil
  "Enable debug messages for org Typst advice.")

(defun org-typst--debug (fmt &rest args)
  (when org-typst-debug
    (apply #'message (concat "[org-typst] " fmt) args)))

(defun org-create-formula-image--typst-advice (orig-fun string tofile options buffer &optional processing-type)
  "Advice for `org-create-formula-image' to add Typst support.

When PROCESSING-TYPE is 'latex and STRING is $ delimited, first try
compiling with Typst. If successful, return the SVG output directly.
Otherwise, fall back to the original LaTeX processing.

ORIG-FUN is the original function.
STRING, TOFILE, OPTIONS, BUFFER, and PROCESSING-TYPE are the original arguments."
  (org-typst--debug "Enter advice: processing-type=%S tofile=%S" processing-type tofile)
  (if (and (eq processing-type org-preview-latex-default-process)
           (numberp (string-match-p "\\`\\s-*\\$" string))
           (numberp (string-match-p "\\$\\s-*\\'" string)))
      (let* ((tmpdir temporary-file-directory)
             (typst-filebase (make-temp-name (expand-file-name "orgtypst" tmpdir)))
             (typst-file (concat typst-filebase ".typ"))
             (svg-file (concat typst-filebase ".svg"))
             (typst-content (replace-regexp-in-string "\\`\\s-*\\$\\s-*\\|\\s-*\\$\\s-*\\'" "" string))
             (normal-type (and (numberp (string-match-p "\\`\\s-*\\$" typst-content)) (numberp (string-match-p "\\$\\s-*\\'" typst-content))))
             (scale (plist-get options :scale))
             (fg-raw (plist-get options (if buffer :foreground :html-foreground)))
             (bg-raw (plist-get options (if buffer :background :html-background)))
             (fg (cond
                  ((null fg-raw) nil)
                  ((eq fg-raw 'default) nil)
                  ((stringp fg-raw) fg-raw)
                  (t nil)))
             (bg (cond
                  ((null bg-raw) nil)
                  ((eq bg-raw 'default) nil)
                  ((string= bg-raw "Transparent") "Transparent")
                  ((stringp bg-raw) bg-raw)
                  (t "Transparent"))))
        (org-typst--debug "Typst candidate: tmpdir=%S typst=%S svg=%S" tmpdir typst-file svg-file)
        (org-typst--debug "Scale=%S fg=%S bg=%S" scale fg bg)
        (condition-case err
            (progn
              (org-typst--debug "Writing Typst file...")
              (with-temp-file typst-file
                (let ((page-fill (cond
                                  ((or (null bg) (string= bg "Transparent")) "#none")
                                  (t (format "rgb(\"%s\")" bg))))
                      (margin (if normal-type 1 0)))
                  (insert (format "#set page(width: auto, height: auto, margin: %dpt, fill: %s)\n" margin page-fill)))
                (when fg
                  (insert (format "#set text(fill: rgb(\"%s\"))\n" fg)))
                (let ((real-content (if normal-type
                                        (replace-regexp-in-string "\\`\\s-*\\$\\s-*\\|\\s-*\\$\\s-*\\'" "" typst-content)
                                      (format "$ %s $" typst-content))))
                  (insert (format "#scale(x:%f*%d%%,y:%f*%d%%,reflow:true)[\n %s \n]" scale org-typst-scale-ratio scale org-typst-scale-ratio real-content))))
              (org-typst--debug "Typst file written: %s (len=%d)" typst-file (nth 7 (file-attributes typst-file)))
              (with-current-buffer (get-buffer-create "*typst-formula*")
                (let ((inhibit-read-only t))
                  (erase-buffer)
                  (insert-file-contents typst-file)))
              (org-typst--debug "Running typst compile...")
              (let* ((compile-buf (get-buffer-create "*typst-compile*"))
                     (exit-code (call-process "typst" nil compile-buf nil
                                              "compile" typst-file svg-file)))
                (org-typst--debug "Typst exit-code=%s svg-exists=%s" exit-code (file-exists-p svg-file))
                (when org-typst-debug
                  (org-typst--debug "Typst output:\n%s"
                                    (with-current-buffer compile-buf
                                      (buffer-substring-no-properties (point-min) (point-max)))))
                (if (and (eq exit-code 0) (file-exists-p svg-file))
                    (progn
                      (org-typst--debug "Typst success; copying %s -> %s" svg-file tofile)
                      (copy-file svg-file tofile 'replace)
                      (when (file-exists-p typst-file) (delete-file typst-file))
                      (when (file-exists-p svg-file) (delete-file svg-file))
                      (org-typst--debug "Typst cleanup done; returning %s" tofile)
                      tofile)
                  (org-typst--debug "Typst failed; cleaning up and falling back to LaTeX")
                  (when (file-exists-p typst-file) (delete-file typst-file))
                  (when (file-exists-p svg-file) (delete-file svg-file))
                  (funcall orig-fun string tofile options buffer processing-type))))
          (error
           (org-typst--debug "Error: %s" (error-message-string err))
           (when (file-exists-p typst-file) (delete-file typst-file))
           (when (file-exists-p svg-file) (delete-file svg-file))
           (org-typst--debug "Fallback to LaTeX due to error")
           (funcall orig-fun string tofile options buffer processing-type))))
    (org-typst--debug "Not a Typst candidate; using original function")
    (funcall orig-fun string tofile options buffer processing-type)))

(after! org
  (advice-add 'org-create-formula-image :around #'org-create-formula-image--typst-advice))
#+end_src

** org-passwords.el

#+begin_src emacs-lisp
(setq org-passwords-file "~/org/passwords.gpg")
#+end_src

** 把一个 region 转换为 org-mode

参考 [[http://yummymelon.com/devnull/converting-a-markdown-region-to-org-revisited.html][nfdn: Converting a Markdown Region to Org Revisited]]

#+begin_src emacs-lisp
(defun my-md-to-org-region (start end)
  "Convert region from markdown to org"
  (interactive "r")
  (shell-command-on-region start end "pandoc -f markdown -t org" t t))
#+end_src

** org-transclusion

#+begin_src emacs-lisp :tangle packages.el
(package! org-transclusion)
#+end_src

#+begin_src emacs-lisp
(with-eval-after-load 'org-transclusion
  (add-to-list 'org-transclusion-extensions 'org-transclusion-indent-mode)
  (require 'org-transclusion-indent-mode))
;; (use-package! org-transclusion
;;               :after org
;;               :init
;;               (map!
;;                :map global-map "<f12>" #'org-transclusion-add
;;                :leader
;;                :prefix "n"
;;                :desc "Org Transclusion Mode" "t" #'org-transclusion-mode))


(use-package! org-transclusion
  :after org
  :init
  (map!
   :map org-mode-map
   :localleader
   :prefix ("u" . "transclUde")
   :desc "Mode" "t" #'org-transclusion-mode
   :desc "Deactivate" "D" #'org-transclusion-deactivate
   :desc "Refresh" "f" #'org-transclusion-refresh

   ;; Adding
   :desc "Add" "a" #'org-transclusion-add
   :desc "Add all" "A" #'org-transclusion-add-all
   :desc "Add From link" "l" #'org-transclusion-make-from-link

   ;; Removing
   :desc "Remove all" "r" #'org-transclusion-remove
   :desc "Remove all" "R" #'org-transclusion-remove-all

   ;; Live sync
   :desc "Start live sync" "s" #'org-transclusion-live-sync-start
   :desc "Stop live sync" "S" #'org-transclusion-live-sync-exit

   ;; Navigating
   :desc "Open source" "o" #'org-transclusion-move-to-source

   ;; Subtrees
   :desc "Demote Subtree" "h" #'org-transclusion-demote-subtree
   :desc "Promote Subtree" "l" #'org-transclusion-promote-subtree)
  :config
  (add-hook 'before-save-hook #'org-transclusion-refresh))

#+end_src

** TODO 在 roam 链接上按 K lookup 打开临时预览窗口

预览窗口是指按 q 退出（能回到上一层预览窗口就更好了）

还有比如说在侧边打开而不是替换原窗口

** ox-hugo :ARCHIVE:
#+begin_src emacs-lisp :tangle no
(after! org
  (setq org-id-extra-files (append (directory-files-recursively org-roam-directory "\.org$")
                                    (list (expand-file-name "config.org" doom-user-dir)))))
#+end_src

** Deft :ARCHIVE:
我觉得完全用不到，这不适合和 org-roam 配合使用

#+begin_src emacs-lisp :tangle no
(after! org
  (setq deft-recursive t
        deft-use-filter-string-for-filename t
        deft-default-extension "org"
        deft-directory org-directory))
#+end_src

** org-supertag :ARCHIVE:
无法正常工作
#+begin_src emacs-lisp :tangle no
(package! org-supertag
  :recipe (:host github :repo "yibie/org-supertag"))
(package! deferred)
(package! epc)
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package! org-supertag
  :after org
  :config
  (org-supertag-setup))

(setq org-supertag-sync-directories '("~/org")) ;; 注意这里不能直接写 org-directory，格式是不一样的，直接写会变成 126 error code
#+end_src

** valign 表格对齐 :ARCHIVE:

不使用 org-modern 的表格美化，改用 valign

#+begin_src emacs-lisp :tangle no
(package! valign)
#+end_src

#+begin_src emacs-lisp :tangle no
(add-hook 'org-mode-hook #'valign-mode)
(after! org
  (setq valign-fancy-bar t
        org-modern-table nil))
#+end_src



* Input Method & 中文支持

我之前本来还想搞分词配置的，结果发现我完全没有这个的需求

** rime config

#+begin_src emacs-lisp
(after! rime
  (setq rime-translate-keybindings
        '("C-h" "C-f" "C-b" "C-n" "C-p" "<tab>" "C-a" "C-s" "C-c")))
#+end_src

** DONE vertico 拼音搜索集成

经在 rime module 里实现了

** 输入法切换快捷键 :ARCHIVE:

将 `toggle-input-method` 从默认的 `C-\` 改为 `C-TAB`，减少右手负担
#+begin_src emacs-lisp :tangle no
(map! [C-tab] #'toggle-input-method)
#+end_src

但是在一些特殊情况下这个快捷键会已经被占用，有点难受
比如说 org-roam-find 的 minibuffer 里
调用的是 [[help:file-cache-minibuffer-complete]]

现在换用 charybdis 键盘之后 \ 离小拇指的距离变近了，就不需要这个配置了

* evil 相关

** insert mode 中 C-n/p 设置为上下行

因为它本来是补全相关的，所以只要改 corfu 的设置就行了

现在我如果要手动唤起补全，就用 C-SPC
然后在唤起 popup 之后用 C-n/p 切换上下待选项依然是可以用的！

#+begin_src emacs-lisp
(after! corfu
  (map! :map corfu-mode-map
        :i "C-n" #'next-line
        :i "C-p" #'previous-line))
#+end_src

** insert mode 中 C-h/l 重新设计

=C-h= 退格， =C-l= 撤回退格操作

#+begin_src emacs-lisp
;; 创建一个变量来存储被删除的字符
(defvar my/evil-insert-deleted-chars nil
  "Stack of characters deleted by C-h in evil insert mode.")

(defun my/evil-insert-backspace ()
  "Delete backward char and save it for potential undo with C-l."
  (interactive)
  (when (> (point) (point-min))
    (let ((char (char-before)))
      (when char
        ;; 将删除的字符推入栈
        (push char my/evil-insert-deleted-chars)
        ;; 删除字符
        (delete-backward-char 1)))))

(defun my/evil-insert-undo-backspace ()
  "Undo the last backspace operation by reinserting the deleted character."
  (interactive)
  (when my/evil-insert-deleted-chars
    ;; 从栈中弹出字符并插入
    (let ((char (pop my/evil-insert-deleted-chars)))
      (insert char))))

;; 清空删除字符栈当退出 insert mode 时
(defun my/evil-insert-clear-deleted-chars ()
  "Clear the deleted characters stack."
  (setq my/evil-insert-deleted-chars nil))

;; 在退出 insert mode 时清空栈
(add-hook 'evil-insert-state-exit-hook #'my/evil-insert-clear-deleted-chars)

;; 绑定按键 - 使用 after! 确保优先级
(map! :i "C-h" #'my/evil-insert-backspace
      :i "C-l" #'my/evil-insert-undo-backspace)

;; 在 org-mode 中也确保生效（需要使用 evil-org-mode-map）
(after! evil-org
  (map! :map evil-org-mode-map
        :i "C-h" #'my/evil-insert-backspace
        :i "C-l" #'my/evil-insert-undo-backspace))
#+end_src

*** TODO minibuffer 支持

* Program
** Languages
*** C/C++

我会把大部分配置写在 CP/cpp 模块里

**** 缩进

#+begin_src emacs-lisp
;; tree-sitter 模式的缩进设置
(setq c-ts-mode-indent-offset 4)
#+end_src

**** 运行与调试

我希望使用 gdb 调试，怎么写 dape 配置？

*** Python

**** lsp-pyright config
切换到 basedpyright

#+begin_src emacs-lisp
(setq lsp-pyright-langserver-command "basedpyright")
#+end_src

**** dape config
自带的 debugpy 配置不能正常工作。。。

**** 缩进示例
#+begin_src emacs-lisp :tangle no
(add-hook 'python-mode-hook
            (lambda ()
              (setq-local tab-width 4)
              (setq-local indent-tabs-mode nil)))
#+end_src

** lsp-mode config

#+begin_src emacs-lisp
(after! lsp-mode
  (setq lsp-idle-delay 0.5
        lsp-log-io nil
        lsp-completion-provider :capf
        lsp-enable-file-watchers nil
        lsp-enable-folding nil
        lsp-enable-text-document-color nil
        lsp-enable-on-type-formatting nil
        lsp-enable-snippet nil
        lsp-enable-symbol-highlighting t        ; 启用符号高亮
        lsp-enable-links nil
        lsp-lens-enable t
        lsp-headerline-breadcrumb-enable t))

;; LSP UI settings for better performance
(after! lsp-ui
  (setq lsp-ui-doc-enable t                     ; 启用文档显示
        lsp-ui-doc-delay 0.3                    ; 文档显示延迟
        lsp-ui-doc-position 'at-point           ; 文档显示位置
        lsp-ui-doc-show-with-cursor nil         ; 光标处显示文档
        lsp-ui-doc-show-with-mouse t            ; 鼠标悬停显示文档

        lsp-ui-sideline-enable t                ; 启用侧边栏
        lsp-ui-sideline-show-diagnostics t      ; 显示诊断信息
        lsp-ui-sideline-show-hover nil          ; 不显示hover信息
        lsp-ui-sideline-show-code-actions t     ; 显示代码操作
        lsp-ui-sideline-update-mode 'line       ; 只在当前行更新
        lsp-ui-sideline-delay 0.1               ; 减少延迟
        lsp-ui-sideline-diagnostic-max-lines 3  ; 每个诊断最多显示行数
        lsp-ui-sideline-diagnostic-max-line-length 100 ; 最大行长度

        lsp-ui-peek-enable t                    ; 启用peek功能
        lsp-ui-imenu-enable t)                  ; 启用imenu集成
  )
#+end_src

** claude-code-ide.el

#+begin_src emacs-lisp :tangle packages.el
(package! claude-code-ide
  :recipe (:host github :repo "manzaltu/claude-code-ide.el"))
#+end_src

** copilot.el

#+begin_src emacs-lisp :tangle packages.el
(package! copilot
  :recipe (:host github :repo "copilot-emacs/copilot.el" :files ("*.el")))
#+end_src


#+begin_src emacs-lisp
;; accept completion from copilot and fallback to company
(use-package! copilot
  :hook (prog-mode . copilot-mode)
  :bind (:map copilot-completion-map
              ("<tab>" . 'copilot-accept-completion)
              ("TAB" . 'copilot-accept-completion)
              ;; ("C-TAB" . 'copilot-accept-completion-by-word)
              ;; ("C-<tab>" . 'copilot-accept-completion-by-word)

              ;; ;; Accept completions (Fish-shell inspired, no conflicts)
              ;; ("<right>" . 'copilot-accept-completion)
              ;; ("C-f" . 'copilot-accept-completion)

              ;; ;; Word-by-word acceptance
              ;; ("M-<right>" . 'copilot-accept-completion-by-word)
              ;; ("M-f" . 'copilot-accept-completion-by-word)

              ;; ;; Line-by-line and navigation
              ;; ("C-e" . 'copilot-accept-completion-by-line)
              ;; ("<end>" . 'copilot-accept-completion-by-line)
              ;; ("M-n" . 'copilot-next-completion)
              ;; ("M-p" . 'copilot-previous-completion)
              ;; ("C-g" . 'copilot-clear-overlay)
              )
  :config
  (setq copilot-indent-offset-warning-disable t)
  ;; (add-to-list 'copilot-indentation-alist '(emacs-lisp-mode 2))

  ;; Enable only in insert state for Evil users
  (when (modulep! :editor evil)
    (setq copilot-enable-predicates '(evil-insert-state-p)))

  ;; Disable in problematic modes
  (add-to-list 'copilot-disable-predicates
               (lambda () (member major-mode '(shell-mode eshell-mode term-mode
                                               vterm-mode comint-mode)))))
#+end_src

*** 遇到的一些小问题
[[https://github.com/copilot-emacs/copilot.el/issues/312][copilot-emacs/copilot.el#312 Warning (copilot): copilot--infer-indentation-of...]]
这个问题主要来自一些模式下 copilot 不能正确推断缩进，这个时候需要我们自己手动配置一下，或者干脆禁用掉这个警告

corfu 的补全可能会覆盖上这个自动上屏的 copilot 的补全，而 company 生态里有 company-box 可以解决这个问题

有一些信息来源说有 company 依赖，实际上是没有的
[[https://emacs-china.org/t/copilot/20348/20?u=0wd0][Copilot 非官方插件 - #20，来自 zerol - Emacs-general - Emacs China]]

** corfu

#+begin_src emacs-lisp
;;; Corfu configuration
(after! corfu
  (setq corfu-auto t                    ; Enable auto completion
        corfu-auto-delay 0.0            ; Balanced performance
        corfu-auto-prefix 2             ; Minimum prefix length
        corfu-cycle t                   ; Enable cycling
        +corfu-want-tab-prefer-expand-snippets t))
#+end_src

** treesit.el

#+begin_src emacs-lisp
(setq treesit-font-lock-level 4)
#+end_src

* Org-mode footnote hover preview :ATTACH:
:PROPERTIES:
:ID:       0908f342-a68a-4358-93da-70f99e7bc20c
:END:

只要窗口不要特别小就不会有问题

后续想要改一下 line wrap 的适配

在 footnote 那边的链接该显示原文的相关内容，或者不搞预览，暂时不管

#+begin_src emacs-lisp
;;; Org-mode footnote hover preview - Enhanced implementation inspired by lsp-ui-doc
(use-package! posframe :defer t)

(defgroup org-footnote-preview nil
  "Preview footnotes in org-mode."
  :group 'org)

(defcustom org-footnote-preview-use-childframe t
  "Whether to use child-frame for footnote preview.
If nil, use posframe instead."
  :type 'boolean
  :group 'org-footnote-preview)

(defcustom org-footnote-preview-position 'at-point
  "Position for footnote preview."
  :type '(choice (const :tag "At Point" at-point)
                 (const :tag "Bottom Left" bottom-left)
                 (const :tag "Top Left" top-left))
  :group 'org-footnote-preview)

(defcustom org-footnote-preview-delay 0.1
  "Delay in seconds before showing footnote preview."
  :type 'number
  :group 'org-footnote-preview)

(defcustom org-footnote-preview-show-with-cursor t
  "Show preview when cursor is on footnote reference."
  :type 'boolean
  :group 'org-footnote-preview)

(defcustom org-footnote-preview-show-with-mouse t
  "Show preview when mouse hovers over footnote reference."
  :type 'boolean
  :group 'org-footnote-preview)

;; Internal variables
(defvar org-footnote-preview-buffer "*org-footnote-preview*")
(defvar org-footnote-preview--frame nil)
(defvar org-footnote-preview--timer nil)
(defvar org-footnote-preview--bounds nil)
(defvar org-footnote-preview--last-point nil)
(defvar org-footnote-preview--mouse-timer nil)
(defvar org-footnote-preview--mouse-last-event nil)

(defconst org-footnote-preview--ignore-commands
  '(org-footnote-preview-hide
    org-footnote-preview-at-point
    org-footnote-preview--handle-mouse-movement
    keyboard-quit
    ignore
    handle-switch-frame
    mwheel-scroll)
  "Commands to ignore for automatic preview.")

(defface org-footnote-preview-background
  `((t :background ,(face-attribute 'tooltip :background nil t)
       :foreground ,(face-attribute 'tooltip :foreground nil t)))
  "Background face for footnote preview."
  :group 'org-footnote-preview)

(defface org-footnote-preview-border
  `((t :background ,(face-attribute 'shadow :foreground nil t)))
  "Border face for footnote preview."
  :group 'org-footnote-preview)

(defun org-footnote-preview--get-definition (label)
  "Get the footnote definition for LABEL."
  (save-excursion
    (goto-char (point-min))
    (when (re-search-forward
           (format "^\\[fn:%s\\]\\s-*\\(.*\\)" (regexp-quote label))
           nil t)
      (let ((start (match-beginning 1))
            (end (save-excursion
                   (if (re-search-forward "^\\[fn:" nil t)
                       (line-beginning-position)
                     (point-max)))))
        (string-trim (buffer-substring-no-properties start end))))))

(defun org-footnote-preview--get-definition-at-point ()
  "Get the footnote definition for the footnote at point."
  (when (org-in-regexp "\\[fn:\\([[:word:]_-]+\\)\\]")
    (let ((label (match-string 1))
          (bounds (cons (match-beginning 0) (match-end 0))))
      (setq org-footnote-preview--bounds bounds)
      (cons label (org-footnote-preview--get-definition label)))))

(defun org-footnote-preview--create-child-frame (buffer)
  "Create child frame for BUFFER."
  (let* ((parent-frame (selected-frame))
         (params `((parent-frame . ,parent-frame)
                   (name . "")
                   (no-accept-focus . t)
                   (min-width . 0)
                   (min-height . 0)
                   (border-width . 2)
                   (internal-border-width . 1)
                   (vertical-scroll-bars . nil)
                   (horizontal-scroll-bars . nil)
                   (left-fringe . 0)
                   (right-fringe . 0)
                   (menu-bar-lines . 0)
                   (tool-bar-lines . 0)
                   (tab-bar-lines . 0)
                   (mode-line-format . nil)  ; 隐藏 modeline
                   (header-line-format . nil)  ; 隐藏 header-line
                   (line-spacing . 0)
                   (unsplittable . t)
                   (no-other-frame . t)
                   (undecorated . t)
                   (cursor-type . nil)
                   (no-special-glyphs . t)
                   (desktop-dont-save . t)
                   ;; 设置精确的窗口边距
                   (left-margin-width . 0)
                   (right-margin-width . 0)
                   (scroll-margin . 0)
                   (background-color . ,(face-attribute 'org-footnote-preview-background :background nil t))
                   (foreground-color . ,(face-attribute 'org-footnote-preview-background :foreground nil t))))
         (window (display-buffer-in-child-frame buffer `((child-frame-parameters . ,params))))
         (frame (window-frame window)))
    (set-face-background 'internal-border
                         (face-attribute 'org-footnote-preview-border :background nil t)
                         frame)
    (when (facep 'child-frame-border)
      (set-face-background 'child-frame-border
                           (face-attribute 'org-footnote-preview-border :background nil t)
                           frame))
    (set-window-dedicated-p window t)
    ;; 完全隐藏各种格式行
    (with-current-buffer buffer
      (setq-local mode-line-format nil)
      (setq-local header-line-format nil)
      (setq-local tab-line-format nil)
      ;; 设置窗口边距为 0
      (setq-local left-margin-width 0)
      (setq-local right-margin-width 0)
      (setq-local scroll-margin 0)
      (setq-local scroll-conservatively 0))
    ;; 确保窗口边距设置生效
    (with-selected-window window
      (set-window-margins window 0 0)
      (set-window-scroll-bars window nil nil))
    frame))

(defun org-footnote-preview--calculate-position (frame)
  "Calculate position for FRAME exactly like lsp-ui-doc's at-point implementation."
  (let* ((edges (window-edges nil t nil t))
         (window-left (nth 0 edges))
         (window-top (nth 1 edges))
         (char-width (frame-char-width))
         (char-height (frame-char-height))
         (frame-width (frame-pixel-width frame))
         (frame-height (frame-pixel-height frame))
         ;; Get symbol position exactly like lsp-ui-doc
         (symbol-pos (or (and org-footnote-preview--bounds
                              (posn-x-y (posn-at-point (car org-footnote-preview--bounds))))
                         (posn-x-y (posn-at-point))))
         (x (car symbol-pos))
         (y (cdr symbol-pos))
         ;; Calculate frame position relative to screen (like lsp-ui-doc)
         ;; Key: offset by 2 char-widths to the right like lsp-ui-doc
         (frame-relative-symbol-x (+ window-left x (* char-width 2)))
         (frame-relative-symbol-y (+ window-top y))
         ;; Horizontal boundary checking (exactly like lsp-ui-doc)
         (frame-x (if (<= (frame-outer-width) (+ frame-relative-symbol-x frame-width))
                      ;; Would exceed right boundary, shift left
                      (- x (- (+ frame-relative-symbol-x frame-width)
                              (frame-outer-width)))
                    ;; Within bounds, use original position with 2-char offset
                    (+ x (* char-width 2))))
         ;; Vertical positioning strategy (exactly like lsp-ui-doc)
         (frame-y (if (<= frame-height frame-relative-symbol-y)
                      ;; Enough space above, show above the symbol
                      (- y frame-height)
                    ;; Not enough space above, show below
                    (+ y char-height))))
    ;; Return absolute screen coordinates
    (cons (+ window-left frame-x) (+ window-top frame-y))))

(defun org-footnote-preview--position-frame (frame)
  "Position FRAME appropriately."
  (when (frame-live-p frame)
    (let* ((window (frame-root-window frame))
           (text-size (window-text-pixel-size window nil nil 1000 1000 t))
           ;; 不需要额外的边距，因为我们已经隐藏了 modeline
           (width (+ (car text-size) (* (frame-char-width frame) 1)))
           ;; 精确的高度，不包含 modeline 空间
           (height (cdr text-size))
           (position (org-footnote-preview--calculate-position frame)))
      ;; 确保最小尺寸
      (setq width (max width (* (frame-char-width frame) 20)))
      (setq height (max height (frame-char-height frame)))
      ;; 设置精确的 frame 大小和位置
      (set-frame-size frame width height t)
      (set-frame-position frame (car position) (cdr position))
      (make-frame-visible frame)
      ;; 确保窗口完全适配内容
      (with-selected-frame frame
        (fit-window-to-buffer window height height width width)))))

(defun org-footnote-preview--display-childframe (content)
  "Display CONTENT using child-frame."
  (let ((buffer (get-buffer-create org-footnote-preview-buffer)))
    (with-current-buffer buffer
      (erase-buffer)
      (insert content)
      (org-mode)
      (goto-char (point-min))
      ;; 完全隐藏 modeline 和相关元素
      (setq-local mode-line-format nil)
      (setq-local header-line-format nil)
      (setq-local tab-line-format nil)
      ;; 禁用行号显示
      (setq-local display-line-numbers nil)
      (setq-local display-line-numbers-mode nil)
      (when (fboundp 'display-line-numbers-mode)
        (display-line-numbers-mode -1))
      ;; 移除多余的空行和空白
      (setq-local cursor-type nil)
      (setq-local show-trailing-whitespace nil)
      ;; 确保没有多余的空行
      (goto-char (point-max))
      (while (and (not (bobp)) (looking-back "\n\n+" nil))
        (delete-char -1))
      (when (fboundp 'org-modern-mode)
        (org-modern-mode 1)))
    (if (and org-footnote-preview--frame
             (frame-live-p org-footnote-preview--frame))
        (with-selected-window (frame-root-window org-footnote-preview--frame)
          (switch-to-buffer buffer))
      (setq org-footnote-preview--frame (org-footnote-preview--create-child-frame buffer)))
    (org-footnote-preview--position-frame org-footnote-preview--frame)))

(defun org-footnote-preview--display-posframe (content)
  "Display CONTENT using posframe."
  (with-current-buffer (get-buffer-create org-footnote-preview-buffer)
    (erase-buffer)
    (insert content)
    (org-mode)
    (goto-char (point-min))
    ;; 禁用行号显示
    (setq-local display-line-numbers nil)
    (setq-local display-line-numbers-mode nil)
    (when (fboundp 'display-line-numbers-mode)
      (display-line-numbers-mode -1)))
  (posframe-show
   org-footnote-preview-buffer
   :position (point)
   :poshandler (pcase org-footnote-preview-position
                 ('bottom-left 'posframe-poshandler-point-bottom-left-corner)
                 ('top-left 'posframe-poshandler-point-top-left-corner)
                 (_ 'posframe-poshandler-point-bottom-left-corner))
   :border-width 2
   :border-color (face-attribute 'org-footnote-preview-border :background nil t)
   :background-color (face-attribute 'org-footnote-preview-background :background nil t)
   :foreground-color (face-attribute 'org-footnote-preview-background :foreground nil t)
   :min-width 40
   :max-width 80
   :timeout 10))

(defun org-footnote-preview--display (content)
  "Display CONTENT in preview."
  (if (and org-footnote-preview-use-childframe
           (fboundp 'display-buffer-in-child-frame)
           (display-graphic-p))
      (org-footnote-preview--display-childframe content)
    (org-footnote-preview--display-posframe content)))

(defun org-footnote-preview-at-point ()
  "Show footnote definition at point."
  (interactive)
  (let ((definition-info (org-footnote-preview--get-definition-at-point)))
    (if definition-info
        (let ((content (cdr definition-info)))
          (if (and content (not (string-empty-p content)))
              (org-footnote-preview--display content)
            (message "Footnote definition is empty")))
      (message "No footnote at point"))))

(defun org-footnote-preview-hide ()
  "Hide footnote preview."
  (interactive)
  (when org-footnote-preview--timer
    (cancel-timer org-footnote-preview--timer)
    (setq org-footnote-preview--timer nil))
  (if org-footnote-preview-use-childframe
      (when (and org-footnote-preview--frame
                 (frame-live-p org-footnote-preview--frame))
        (delete-frame org-footnote-preview--frame)
        (setq org-footnote-preview--frame nil))
    (posframe-hide org-footnote-preview-buffer))
  (setq org-footnote-preview--bounds nil
        org-footnote-preview--last-point nil))

(defun org-footnote-preview--should-show-p ()
  "Return t if we should show preview."
  (and org-footnote-preview-show-with-cursor
       (not (minibufferp))
       (not (memq this-command org-footnote-preview--ignore-commands))
       (org-in-regexp "\\[fn:\\([[:word:]_-]+\\)\\]")))

(defun org-footnote-preview--auto-show ()
  "Automatically show preview if appropriate."
  (let ((current-point (point)))
    ;; 如果光标在脚注引用上，显示预览
    (if (org-in-regexp "\\[fn:\\([[:word:]_-]+\\)\\]")
        (let ((definition-info (org-footnote-preview--get-definition-at-point)))
          (when (and definition-info (cdr definition-info)
                     (not (string-empty-p (cdr definition-info))))
            ;; 只有在位置改变时才重新显示，避免闪烁
            (unless (equal current-point org-footnote-preview--last-point)
              (org-footnote-preview--display (cdr definition-info))
              (setq org-footnote-preview--last-point current-point))))
      ;; 不在脚注引用上，隐藏预览
      (when org-footnote-preview--last-point
        (org-footnote-preview-hide)
        (setq org-footnote-preview--last-point nil)))))

(defun org-footnote-preview--make-request ()
  "Make request for footnote preview."
  ;; Setup mouse tracking like lsp-ui-doc
  (and (not track-mouse) org-footnote-preview-show-with-mouse (setq-local track-mouse t))

  (when (and org-footnote-preview-show-with-cursor
             (not (minibufferp))
             (not (memq this-command org-footnote-preview--ignore-commands)))
    (when org-footnote-preview--timer
      (cancel-timer org-footnote-preview--timer))
    ;; 更短的延迟，更快响应
    (setq org-footnote-preview--timer
          (run-with-idle-timer 0.1 nil #'org-footnote-preview--auto-show))))

;; Mouse support functions - 基于 lsp-ui-doc 的实现
(defun org-footnote-preview--handle-mouse-movement (event)
  "Handle mouse movement EVENT for footnote preview."
  (interactive "e")
  (when org-footnote-preview-show-with-mouse
    (when org-footnote-preview--mouse-timer
      (cancel-timer org-footnote-preview--mouse-timer))
    (let* ((e (cadr event))
           (point (posn-point e))
           (same-win (eq (selected-window) (posn-window e))))
      ;; Hide if mouse moved away from footnote
      (and org-footnote-preview--bounds
           point
           (or (< point (car org-footnote-preview--bounds))
               (> point (cdr org-footnote-preview--bounds))
               (not same-win))
           (org-footnote-preview-hide))
      ;; Show if mouse is on footnote in same window
      (when (and same-win point)
        (setq org-footnote-preview--mouse-last-event point
              org-footnote-preview--mouse-timer
              (run-with-idle-timer 0.2 nil #'org-footnote-preview--mouse-display))))))

(defun org-footnote-preview--mouse-display ()
  "Display footnote preview at mouse position."
  (when (and org-footnote-preview--mouse-last-event
             org-footnote-preview-show-with-mouse)
    (save-excursion
      (goto-char org-footnote-preview--mouse-last-event)
      (when (org-in-regexp "\\[fn:\\([[:word:]_-]+\\)\\]")
        (let ((definition-info (org-footnote-preview--get-definition-at-point)))
          (when (and definition-info (cdr definition-info)
                     (not (string-empty-p (cdr definition-info))))
            (org-footnote-preview--display (cdr definition-info))))))))

(defun org-footnote-preview--setup-mouse ()
  "Setup mouse tracking for footnote preview."
  (when org-footnote-preview-show-with-mouse
    ;; Use keymap binding like lsp-ui-doc, not hook
    (local-set-key (kbd "<mouse-movement>") #'org-footnote-preview--handle-mouse-movement)
    (setq-local track-mouse t)))

;; Enhanced keybindings
(map! :map org-mode-map
      :desc "Preview footnote" "C-c f p" #'org-footnote-preview-at-point
      :desc "Hide footnote preview" "C-c f h" #'org-footnote-preview-hide
      :desc "Preview footnote at point" "C-c C-d" #'org-footnote-preview-at-point)

;; Auto-preview mode
(define-minor-mode org-footnote-preview-mode
  "Minor mode for automatic footnote preview."
  :lighter " FnPrev"
  :group 'org-footnote-preview
  (if org-footnote-preview-mode
      (progn
        (add-hook 'post-command-hook #'org-footnote-preview--make-request nil t)
        (add-hook 'window-scroll-functions
                  (lambda (&rest _) (org-footnote-preview-hide)) nil t)
        (org-footnote-preview--setup-mouse))
    (remove-hook 'post-command-hook #'org-footnote-preview--make-request t)
    (remove-hook 'window-scroll-functions
                 (lambda (&rest _) (org-footnote-preview-hide)) t)
    ;; Clean up mouse binding
    (when org-footnote-preview-show-with-mouse
      (local-unset-key (kbd "<mouse-movement>")))
    (when org-footnote-preview--timer
      (cancel-timer org-footnote-preview--timer)
      (setq org-footnote-preview--timer nil))
    (when org-footnote-preview--mouse-timer
      (cancel-timer org-footnote-preview--mouse-timer)
      (setq org-footnote-preview--mouse-timer nil))
    (org-footnote-preview-hide)))

;; Auto-enable in org-mode
(add-hook 'org-mode-hook #'org-footnote-preview-mode)
#+end_src
