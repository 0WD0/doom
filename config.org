#+begin_src emacs-lisp
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-
#+end_src
这个词法作用域配置是必要的

这是一些在配置 doom 时可能有帮助的额外的 函数/宏
 - `load!' for loading external *.el files relative to this one
 - `use-package!' for configuring packages
 - `after!' for running code after a package has loaded
 - `add-load-path!' for adding directories to the `load-path', relative to
   this file. Emacs searches the `load-path' when you load packages with
   `require' or `use-package'.
 - `map!' for binding new keys

Whenever you reconfigure a package, make sure to wrap your config in an
`after!' block, otherwise Doom's defaults may override your settings. E.g.

  (after! PACKAGE
    (setq x y))

The exceptions to this rule:

  - Setting file/directory variables (like `org-directory')
  - Setting variables which explicitly tell you to set them before their
    package is loaded (see 'C-h v VARIABLE' to look up their documentation).
  - Setting doom variables (which start with 'doom-' or '+').

To get information about any of these functions/macros, move the cursor over the highlighted symbol at press 'K' (non-evil users must press 'C-c c k').
This will open documentation for it, including demos of how they are used. Alternatively, use `C-h o' to look up a symbol (functions, variables, faces, etc).
You can also try 'gd' (or 'C-c c d') to jump to their definition and see how they are implemented.

* packages.el
#+begin_src emacs-lisp :tangle packages.el
;;; $DOOMDIR/packages.el -*- no-byte-compile: t; -*-
#+end_src
使用 Doom 安装软件包时，必须在此处声明并运行命令行中的 'doom sync'，然后重启 Emacs 才能让更改生效 -- 或者

从 MELPA、ELPA 或 emacsmirror 安装 SOME-PACKAGE：
~(package! some-package)~

若要从远程 Git 仓库直接安装软件包，您需要指定一个 ~:recipe~ （配方）
关于 ~:recipe~ 接受的格式说明请参见： https://github.com/radian-software/straight.el#the-recipe-format
(package! another-package
  :recipe (:host github :repo "username/repo"))

当您要安装的包中没有 PACKAGENAME.el 文件，或该文件位于仓库子目录中时，您需要在 `:recipe' 中指定 `:files'：
(package! this-package
  :recipe (:host github :repo "username/repo"
           :files ("some-file.el" "src/lisp/*.el")))

如果想要禁用 Doom 自带的包，可以在此处使用 ~:disable~ 属性：
(package! builtin-package :disable t)

您可以无需指定 ~:recipe~ 的所有属性，就覆盖内置包的配方。这些设置将继承其他部分的配方信息（来自 Doom 或 MELPA/ELPA/Emacsmirror）：
(package! builtin-package :recipe (:nonrecursive t))
(package! builtin-package-2 :recipe (:repo "myfork/package"))

使用 ~:branch~ 指定从特定分支或标签安装包（某些默认分支不是 'master' 的包需要此项配置，因为当前包管理器无法处理；参见 radian-software/straight.el#279）：
(package! builtin-package :recipe (:branch "develop"))

使用 ~:pin~ 指定特定提交哈希来安装包：
(package! builtin-package :pin "1a2b3c4d5e")

Doom 的所有包都默认绑定到特定提交哈希，并在版本更新时更新。使用 `unpin!' 宏可以解除单个包的绑定...
(unpin! pinned-package)
...或多个包
(unpin! pinned-package another-pinned-package)
...或者 *全部* 包（不推荐，很可能导致错误）
(unpin! t)

* 基础设置

** Theme
There are two ways to load a theme. Both assume the theme is installed and
available. You can either set `doom-theme' or manually load a theme with the
`load-theme' function.

#+begin_src emacs-lisp :tangle packages.el
(package! catppuccin-theme)
#+end_src

#+begin_src emacs-lisp
(setq doom-theme 'catppuccin)
(setq catppuccin-flavor 'frappe)
#+end_src

** Fonts
Doom exposes five (optional) variables for controlling fonts in Doom:

- `doom-font' -- the primary font to use
- `doom-variable-pitch-font' -- a non-monospace font (where applicable)
- `doom-big-font' -- used for `doom-big-font-mode'; use this for
  presentations or streaming.
- `doom-symbol-font' -- for symbols
- `doom-serif-font' -- for the `fixed-pitch-serif' face

See 'C-h v doom-font' for documentation and more examples of what they
accept. For example:


If you or Emacs can't find your font, use 'M-x describe-font' to look them
up, `M-x eval-region' to execute elisp code, and 'M-x doom/reload-font' to
refresh your font settings. If Emacs still can't find your font, it likely
wasn't installed correctly. Font issues are rarely Doom issues!
#+begin_src emacs-lisp
;; 日常阅读使用 Fira Code，代码使用 Fira Code
(setq doom-font (font-spec :family "Fira Code" :size 24 :weight 'normal)
      doom-variable-pitch-font (font-spec :family "Fira Code" :size 24)
      doom-big-font (font-spec :family "Fira Code" :size 36)
      doom-serif-font (font-spec :family "Fira Sans" :size 24))

;; 中文字体配置 - 使用最佳实践
(defun my-cjk-font ()
  "Set CJK font for mixed Chinese-English display"
  (dolist (charset '(kana han cjk-misc symbol bopomofo))
    (set-fontset-font t charset (font-spec :family "LXGW WenKai"))))

(add-hook 'after-setting-font-hook #'my-cjk-font)

;; 设定所有英文斜体使用 Hack Nerd Font
(custom-set-faces!
 '(italic :family "Hack Nerd Font" :slant italic))
#+end_src

** Line numbers

#+begin_src emacs-lisp
(setq! display-line-numbers-type t)
#+end_src

** Mail

#+begin_src elisp :tangle packages.el
(package! mu4e)
#+end_src

#+begin_src elisp
(add-load-path! "/usr/share/emacs/site-lisp/mu4e/")
#+end_src
see [[https://github.com/doomemacs/doomemacs/issues/7885][doomemacs/doomemacs#7885 Can't open mu4e]]

#+begin_src elisp :tangle no
(setq! +mu4e-gmail-accounts '(("wd.1105848296@gmail.com" . "gmail")))
#+end_src

#+begin_src elisp
(set-email-account!
 "qq"
 '((user-full-name        . "0WD0")
   (user-mail-address     . "1105848296@qq.com")
   (smtpmail-smtp-user    . "1105848296@qq.com")
   (smtpmail-smtp-server  . "smtp.qq.com")
   (smtpmail-smtp-service . 465)
   (smtpmail-stream-type  . ssl)
   (mu4e-drafts-folder    . "/qq/Drafts")
   (mu4e-sent-folder      . "/qq/Sent Messages")
   (mu4e-trash-folder     . "/qq/Deleted Messages")
   (mu4e-maildir-shortcuts . (
                              ("/qq/INBOX"       . ?i)
                              ("/qq/Sent Messages"        . ?s)))
   (+mu4e-personal-addresses . '("1105848296@qq.com")))
 t) ; true 表示默认账号

(set-email-account!
 "hdu"
 '((user-full-name        . "WD")
   (user-mail-address     . "24062034@hdu.edu.cn")
   (smtpmail-smtp-user    . "24062034@hdu.edu.cn")
   (smtpmail-smtp-server  . "smtp.hdu.edu.cn")
   (smtpmail-smtp-service . 465)
   (smtpmail-stream-type  . ssl)
   (mu4e-drafts-folder    . "/hdu/草稿箱")
   (mu4e-sent-folder      . "/hdu/已发送")
   (mu4e-trash-folder     . "/hdu/已删除")
   (mu4e-maildir-shortcuts . (("/hdu/INBOX"       . ?i)
                              ("/hdu/已发送"        . ?s)))
   (+mu4e-personal-addresses . '("24062034@hdu.edu.cn"))))

(set-email-account!
 "gmail"
 '((user-full-name        . "0WD0")
   (user-mail-address     . "wd.1105848296@gmail.com")
   (smtpmail-smtp-user    . "wd.1105848296@gmail.com")
   (smtpmail-smtp-server  . "smtp.gmail.com")
   (smtpmail-smtp-service . 587)
   (smtpmail-stream-type  . starttls)
   (mu4e-drafts-folder    . "/gmail/[Gmail]/草稿")
   (mu4e-sent-folder      . "/gmail/[Gmail]/已发邮件")
   (mu4e-trash-folder     . "/gmail/[Gmail]/已删除邮件")
   (mu4e-refile-folder    . "/gmail/[Gmail]/所有邮件")
   (+mu4e-personal-addresses . '("wd.1105848296@gmail.com"))))
#+end_src

** Line Wrap

[[https://www.emacswiki.org/emacs/LineWrap][EmacsWiki: Line Wrap]]
[[https://emacs-china.org/t/topic/2616/34][中英文混排时候的自动折行？ - #34，来自 ltylty - Emacs-general - Emacs China]]

*** CJK 字符换行支持

#+begin_src emacs-lisp
(setq! word-wrap-by-category t)
(modify-category-entry '(45 . 47) ?|)  ;; ASCII 45-47, i.e. ",-/"
(modify-category-entry 58 ?|)          ;; ASCII 58, i.e. ":"
#+end_src

* org-mode

org 是一个强大的笔记和文档管理工具，Doom Emacs 提供了许多配置选项来增强 org-mode 的功能。

#+begin_src emacs-lisp :tangle packages.el
(unpin! org-roam)
#+end_src

#+begin_src emacs-lisp
(add-hook! 'org-mode-hook (lambda () (setq-local tab-width 8)))
(setq! org-directory "~/org"
      org-roam-directory "~/org/roam"
      org-roam-completion-everywhere t
      org-agenda-files (directory-files-recursively "~/org/" "\\.org$")
      org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-id-link-consider-parent-id t
      ;; org-confirm-babel-evaluate nil
      org-edit-src-content-indentation 0
      org-link-search-must-match-exact-headline nil ;; 这东西的默认设置是真逆天
      )
#+end_src

#+begin_src emacs-lisp :tangle no
(with-eval-after-load 'org
  (let ((cn-punct "，。、：；！？“”‘’（）【】《》〈〉「」『』—……·"))
    (setcar org-emphasis-regexp-components
            (concat (car org-emphasis-regexp-components) cn-punct))
    (setcar (nthcdr 1 org-emphasis-regexp-components)
            (concat (nth 1 org-emphasis-regexp-components) cn-punct))
    (org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components)))
#+end_src

#+begin_src emacs-lisp
(after! org
  (dolist (i '(0 1))
    (setcar (nthcdr i org-emphasis-regexp-components)
            (concat (nth i org-emphasis-regexp-components) "[:nonascii:]")))
  (org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components))
#+end_src

** org-agenda

*** org-agenda-custom-commands
#+begin_src elisp
(after! org-agenda
  (add-to-list 'org-agenda-custom-commands
               '("c" "competitions" agenda ""
                 ((org-agenda-files '("~/orgcalendar.org"))
                  (org-agenda-time-grid nil)
                  ))
               ))
#+end_src

*** org-agenda-prefix-format

这里出现了一个中文不等宽的问题。。。
用 fn:truncate-string-to-width 解决了
我现在觉得中英文等宽有点不协调，之后再说了

现在还会有会报 warning 的问题
具体来说就是有很多
⛔ Warning (org-element): ‘org-element-at-point’ cannot be used in non-Org buffer #<buffer *Org Agenda*> (org-agenda-mode)

#+begin_src emacs-lisp
(setq! org-agenda-prefix-format
       '((agenda . " %i %(my/agenda-category 30)%?-12t% s")
         (todo . " %i %(my/agenda-category 30) ")
         (tags . " %i %(my/agenda-category 30) ")
         (search . " %i %(my/agenda-category 30) ")))

(after! org
  (defun my/agenda-category (&optional len)
    "Get category of item at point for agenda.

Category is defined by one of the following items:

- CATEGORY property
- TITLE keyword
- TITLE property
- filename without directory and extension

When LEN is a number, resulting string is padded right with
spaces and then truncated with ... on the right if result is
longer than LEN.

Usage example:

  (setq org-agenda-prefix-format
        '((agenda . \" %(my/agenda-category) %?-12t %12s\")))

Refer to `org-agenda-prefix-format' for more information."
    (if (not (derived-mode-p 'org-mode))
        (if (numberp len)
            (make-string len ?\s))
      (let* ((file-name (when buffer-file-name
                          (file-name-sans-extension
                           (file-name-nondirectory buffer-file-name))))
             (title (org-get-title))
             (category (org-get-category))
             (result
              (or (if (and title (string-equal category file-name))
                      title
                    category)
                  "")))
        (if (numberp len)
            (truncate-string-to-width result len nil ?\s t)
          result))))
  )
#+end_src

*** diary-course
稍微讲一讲需求

首先预先设定每学期的校历
校历由三个部分组成
1. 起止日期
2. 放假日期
   需要支持两种形式，单点和区间
3. 调休日期
   表示在之后的处理中把一天替换成另一天

现在基本功能已经正常工作了，自定义筛选函数还没有测试

-----

diary-course 是一个 sexp diary entry
输入有三个 课程在第几个学期 课程在星期几 一个用来判定第几周有没有课的函数（可选，若空就是每周都有）

具体流程如下：
判断一个日期是否是预先设定的假期
然后看是不是调休，做一下映射
最后得到 这一天是这学期第几周的星期几
判一下星期几对不对得上
然后把第几周作用在筛选函数上再判断一遍
下面给出一个可直接放入 org/diary 的 Emacs Lisp 方案。包含：
- 学期配置：起止日期、放假（单点/区间）、调休映射
- 核心工具函数：日期比较、周序号计算、假期/调休判定与映射
- diary-course SEXP 条目：按你的流程判断是否匹配某门课

使用方法：
- 将以下代码放入你的 init.el 或专门的 .el 文件并加载
- 在 org/agenda 的 diary file 中添加类似 (diary-course 1 2 nil) 的条目
  含义：第1学期、每周二、每周都有课（筛选函数为 nil）

代码如下：

#+begin_src emacs-lisp
;; =========================
;; 配置区：学期与校历
;; =========================

(defvar my-academic-terms
  ;; 每个学期是一个 plist：
  ;; :name        学期名（可选）
  ;; :range       (start end) 含首尾，格式 (month day year)
  ;; :holidays    放假，支持混合列表：单点 (m d y) 或区间 ((m d y) (m d y))
  ;; :adjustments 调休，列表形式：((from-m from-d from-y) (to-m to-d to-y))
  ;;              表示把 from 那天的课改到 to 那天（查询时把 to 映射回 from 判定周次与星期）
  ;; 说明：:adjustments 的方向通常用 “把某个工作日安排到另一天上课”，
  ;; 在判定当天课程时，我们将“查询日”映射回“原日”以使用原日的周次/星期逻辑。
  [
   ;; 示例：2024-09-02 至 2025-01-10
   (:name "2024-秋"
    :range ((9 2 2024) (1 10 2025))
    :holidays ( ;; 单点
               (10 1 2024) (10 2 2024) (10 3 2024)
               ;; 区间
               ((9 29 2024) (10 6 2024)))
    :adjustments (
                  ;; 把 2024-10-07 的课挪到 2024-10-12 上
                  ((10 7 2024) (10 12 2024))
                  ;; 把 2024-09-29 的课挪到 2024-10-08 上
                  ((9 29 2024) (10 8 2024))
                  ))

   ;; 再示例一个学期：2025-02-24 至 2025-07-04
   (:name "2025-春"
    :range ((2 24 2025) (7 4 2025))
    :holidays ( (5 1 2025) ((6 1 2025) (6 3 2025)) )
    :adjustments ( ((4 7 2025) (4 12 2025)) ))

   (:name "2025-秋"
    :range ((9 15 2025) (1 11 2026))
    :holidays (
               (1 1 2026)
               (10 30 2025) (10 31 2025)
               ((10 1 2025) (10 8 2025)))
    :adjustments (
                  ((10 7 2025) (9 28 2025))
                  ((10 8 2025) (10 11 2025))
                  ))
   ])
#+end_src

#+begin_src emacs-lisp
;; =========================
;; 工具函数
;; =========================

(defun my-date-to-abs (date)
  "DATE: (month day year) -> absolute day number."
  (let ((m (nth 0 date)) (d (nth 1 date)) (y (nth 2 date)))
    (calendar-absolute-from-gregorian (list m d y))))

(defun my-abs-to-date (abs-day)
  (let* ((g (calendar-gregorian-from-absolute abs-day)))
    (list (nth 0 g) (nth 1 g) (nth 2 g))))

(defun my-date<= (a b)
  (<= (my-date-to-abs a) (my-date-to-abs b)))

(defun my-date< (a b)
  (< (my-date-to-abs a) (my-date-to-abs b)))

(defun my-date= (a b)
  (= (my-date-to-abs a) (my-date-to-abs b)))

(defun my-date-in-range-p (date range)
  "RANGE: ((m d y) (m d y)) inclusive."
  (let ((s (car range)) (e (cadr range)))
    (and (my-date<= s date) (my-date<= date e))))

(defun my-day-of-week (date)
  "Return Emacs weekday number: 0=Sunday ... 6=Saturday."
  (let ((m (nth 0 date)) (d (nth 1 date)) (y (nth 2 date)))
    (calendar-day-of-week (list m d y))))

(defun my-find-term (date)
  "在 my-academic-terms 中找到包含 DATE 的学期 plist。"
  (let* ((abs (my-date-to-abs date))
         (len (length my-academic-terms))
         (idx 0)
         found)
    (while (and (< idx len) (not found))
      (let* ((term (aref my-academic-terms idx))
             (range (plist-get term :range)))
        (when (my-date-in-range-p date range)
          (setq found term)))
      (setq idx (1+ idx)))
    found))

(defun my-term-start (term)
  (car (plist-get term :range)))

(defun my-term-end (term)
  (cadr (plist-get term :range)))

(defun my-holiday-p (date term)
  "判断 DATE 是否在 TERM 的放假日中。支持单点或区间。"
  (let ((hs (plist-get term :holidays))
        (abs (my-date-to-abs date))
        hit)
    (dolist (h hs)
      (cond
       ;; 单点
       ((and (listp h) (= (length h) 3))
        (when (= abs (my-date-to-abs h))
          (setq hit t)))
       ;; 区间
       ((and (listp h) (= (length h) 2))
        (when (my-date-in-range-p date h)
          (setq hit t)))))
    hit))

(defun my-adjustment-find-to->from (date term)
  "若 DATE 是某个调休的 to 日，返回对应的 from 日；否则返回 nil。
调休表示：把 from 那天的课挪到 to 那天上。查询时需把 to 映射回 from。"
  (let* ((to-abs (my-date-to-abs date))
         (adjs (plist-get term :adjustments))
         found)
    (dolist (pair adjs)
      (let ((from (nth 0 pair))
            (to   (nth 1 pair)))
        (when (= to-abs (my-date-to-abs to))
          (setq found from))))
    found))

(defun my-week-index-in-term (date term)
  "计算 DATE 在 TERM 中的周序号（从 1 开始）。
以 TERM 起始日为第一周的周1，如果起始日不是周一，则起始日所在周算第1周的剩余天数。
实现为：floor((date - term-start)/7) + 1"
  (let* ((start (my-term-start term))
         (delta (- (my-date-to-abs date) (my-date-to-abs start))))
    (1+ (floor (/ delta 7)))))
#+end_src

#+begin_src emacs-lisp
;; =========================
;; 主函数：diary-course
;; =========================
(defun diary-course (term-index weekday &optional filter-fn)
  "SEXP diary entry，用于 org-agenda。
- TERM-INDEX: 第几个学期，从 1 开始，对应 my-academic-terms 的顺序
- WEEKDAY: Emacs weekday, 0=周日 ... 6=周六
- FILTER-FN: 一个函数，接受周序号（正整数），返回 t/nil；
流程：
1) 判定是否在 term-index 指定学期内；若不在，返回 nil
2) 若为假期，直接返回 nil
3) 若当天是某个调休的 to 日，则将查询日期映射回 from 日用于周与星期判定
4) 计算该（映射后）日期是学期第几周、星期几
5) 星期匹配 + 过滤函数判定
返回字符串（用于显示）或 nil。"
  (let* ((terms my-academic-terms)
         (idx (1- term-index)))
    (when (and (>= idx 0) (< idx (length terms)))
      (let* ((term (aref terms idx)))
        (when (my-date-in-range-p date (plist-get term :range))
          ;; 1) 假期直接排除
          (unless (my-holiday-p date term)
            ;; 2) 调休映射：如果 date 是某条调整的 to，则映射到 from
            (let* ((mapped (or (my-adjustment-find-to->from date term) date))
                   (w (my-week-index-in-term mapped term))
                   (dow (my-day-of-week mapped)))
              (when (and (= dow weekday)
                         (or (null filter-fn) (funcall filter-fn w)))
                ;; 返回一个简短描述，包含学期名/周次
                (let* ((term-name (or (plist-get term :name)
                                      (format "Term-%d" term-index))))
                  (format "%s: Week %d" term-name w))))))))))
#+end_src

这里用 doom-package:llama 来写匿名函数能短很多！
它是 doom-package:magit 的依赖（毕竟是同一个开发者）

我觉得 llama 原版的 <fn:##> 写起来还是比 doom 改的 <fn:fn!> 方便的
#+begin_src emacs-lisp :tangle packages.el
(package! llama)
#+end_src

可以积累一下常用的函数
~#'evenp~ 双周
~#'oddp~ 单周
~(##<= 4 % 8)~ 区间周

*** sunrise/sunset

虽然有 =%%(diary-sunrise-sunset)= 这个东西可以用，但是这个形式并不好看，还是抄一个比较好
#+begin_src emacs-lisp
;;Sunrise and Sunset
;;日出而作, 日落而息
(defun diary-sunrise ()
  (let ((dss (diary-sunrise-sunset)))
    (with-temp-buffer
      (insert dss)
      (goto-char (point-min))
      (while (re-search-forward " ([^)]*)" nil t)
        (replace-match "" nil nil))
      (goto-char (point-min))
      (search-forward ",")
      (buffer-substring (point-min) (match-beginning 0)))))

(defun diary-sunset ()
  (let ((dss (diary-sunrise-sunset))
        start end)
    (with-temp-buffer
      (insert dss)
      (goto-char (point-min))
      (while (re-search-forward " ([^)]*)" nil t)
        (replace-match "" nil nil))
      (goto-char (point-min))
      (search-forward ", ")
      (setq start (match-end 0))
      (search-forward " at")
      (setq end (match-beginning 0))
      (goto-char start)
      (capitalize-word 1)
      (buffer-substring start end))))
#+end_src

** UI

*** My +pretty

#+begin_src emacs-lisp
(setq! org-highlight-latex-and-related '(native script entities)
       org-hide-emphasis-markers t
       org-pretty-entities t)
#+end_src
这个 var:org-pretty-entities 和 [[doom-module:ui emoji]] 有冲突

#+begin_src emacs-lisp :tangle packages.el
(package! org-appear :pin "32ee50f8fdfa449bbc235617549c1bccb503cb09")
(package! org-modern :pin "1723689710715da9134e62ae7e6d41891031813c")
(package! org-modern-indent
  :recipe (:host github :repo "jdtsmith/org-modern-indent"))
#+end_src

#+begin_src emacs-lisp
(after! org
  (setq! org-appear-autosubmarkers t
         org-appear-inside-latex t
         org-appear-autolinks 'just-brackets
         org-appear-autoentities t))

(use-package! org-appear
  :hook (org-mode . org-appear-mode))

(add-hook 'org-mode-hook #'org-modern-indent-mode 90)

(use-package! org-modern
  :hook (org-mode . org-modern-mode)
  :hook (org-agenda-finalize . org-modern-agenda)
  :init
  (setq org-modern-todo nil
        org-modern-list '((43 . "◦") (45 . "•") (42 . "–")))

  :config
  ;; HACK: The default unicode symbol for checked boxes often turn out much
  ;;   larger than the others, so I swap it out with one that's more likely to
  ;;   be consistent.
  (setf (alist-get ?X org-modern-checkbox) #("□x" 0 2 (composition ((2)))))

  ;; HACK: If `org-indent-mode' is active, org-modern's default of hiding
  ;;   leading stars makes sub-headings look too sunken into the left margin.
  ;;   Those stars are already "hidden" by `org-hide-leading-stars' anyway, so
  ;;   rely on just that.
  (add-hook! 'org-modern-mode-hook
    (defun +org-modern-show-hidden-stars-in-indent-mode-h ()
      (when (bound-and-true-p org-indent-mode)
        (setq-local org-modern-hide-stars nil))))

  ;; Carry over the default values of `org-todo-keyword-faces', `org-tag-faces',
  ;; and `org-priority-faces' as reasonably as possible, but only if the user
  ;; hasn't already modified them.
  (letf! (defun new-spec (spec)
           (if (or (facep (cdr spec))
                   (not (keywordp (car-safe (cdr spec)))))
               `(:inherit ,(cdr spec))
             (cdr spec)))
    (unless org-modern-tag-faces
      (dolist (spec org-tag-faces)
        (add-to-list 'org-modern-tag-faces `(,(car spec) :inverse-video t ,@(new-spec spec)))))
    (unless org-modern-todo-faces
      (dolist (spec org-todo-keyword-faces)
        (add-to-list 'org-modern-todo-faces `(,(car spec) :inverse-video t ,@(new-spec spec)))))
    (unless org-modern-priority-faces
      (dolist (spec org-priority-faces)
        (add-to-list 'org-modern-priority-faces `(,(car spec) :inverse-video t ,@(new-spec spec)))))))
#+end_src

*** org-mode 标题颜色设置

#+begin_src emacs-lisp
(custom-set-faces!
   '(org-level-1 :foreground "#c6d0f5" :weight bold :height 1.3)      ; 纯文本色，最亮
   '(org-level-2 :foreground "#b5bfe2" :weight semi-bold :height 1.2) ; 稍微暗一点
   '(org-level-3 :foreground "#a4aed0" :weight semi-bold :height 1.1) ; 更暗
   '(org-level-4 :foreground "#939dbd" :weight normal)                ; 继续变暗
   '(org-level-5 :foreground "#828cab" :weight normal)                ; 更暗
   '(org-level-6 :foreground "#717b98" :weight normal)                ; 再暗
   '(org-level-7 :foreground "#606a86" :weight normal)                ; 很暗
   '(org-level-8 :foreground "#4f5973" :weight normal))               ; 最暗
#+end_src

*** org-mode 代码块颜色配置

#+begin_src emacs-lisp
;; 自定义 org-mode 代码块颜色 - 与 catppuccin frappe 主题协调
(after! org
  (custom-set-faces!
   ;; 代码块开始/结束标记
   '(org-block-begin-line :background "#232634" :foreground "#737994" :extend t)
   '(org-block-end-line :background "#232634" :foreground "#737994" :extend t)
   ;; 行内代码颜色
   '(org-block :foreground "#c6d0f5" :extend t)))
#+end_src

*** 对 org-mode 禁用 indent-bars

#+begin_src emacs-lisp
(add-hook 'org-mode-hook
          (lambda ()
            (when (bound-and-true-p indent-bars-mode)
              (indent-bars-mode -1))))
#+end_src

** org-roam 增强

*** 快速打开 =:ROAM_REFS:=

一般来说不会有很多 ROAM_REFS

竟然这么好实现

之后可以和 citar 集成一下

#+begin_src emacs-lisp
(defun my/open-roam-refs ()
  "Open one of the ROAM_REFS links for current entry."
  (interactive)
  (let ((refs (org-entry-get nil "ROAM_REFS")))
    (when refs
      (let* ((links (split-string refs " "))
             (link (completing-read "Open link: " links)))
        (browse-url link)))))

(map! :map org-mode-map
      :localleader
      :prefix ("m" . "org-roam")
      "b" #'my/open-roam-refs)
#+end_src


*** 算法竞赛模板导出工具

以后可以直接用这个
#+begin_src elisp :tangle no
(my/org-roam-export-top-tagged-subtrees-to-pdf my/org-roam-export-tags)
#+end_src

**** 关键tag

#+begin_src emacs-lisp
(defvar my/org-roam-export-tag nil)

;; 还没有适配预先设置的
(defvar my/org-roam-export-tags '("CP" "CF" "HDU" "nowcoder" "atcoder" "luogu" "contest"))

;; Helper function to handle both single tag and multiple tags
(defun my/normalize-tags (tags)
  "Convert TAGS to a list if it's a string, otherwise return as-is."
  (if (stringp tags) (list tags) tags))

;; Helper function to convert string to pinyin for sorting, preserving non-Chinese characters
(defun my/string-to-pinyin-for-sort (str)
  "Convert STR to pinyin for sorting. Chinese characters are converted to pinyin,
non-Chinese characters (like English letters) are preserved at their original positions."
  (let ((result ""))
    (dolist (char (string-to-list str))
      (let ((char-str (char-to-string char)))
        (setq result
              (concat result
                      (if (and (>= char #x4e00) (<= char #x9fff))  ; Chinese character range
                          (pyim-cstring-to-pinyin char-str "")
                        char-str)))))
    (downcase result)))
#+end_src

之后需要看看怎么扩展到多个 tag
已经完成多 tag 支持！现在可以这样使用：

#+begin_src elisp :tangle no
;; 使用单个 tag
(my/org-roam-export-top-tagged-subtrees-to-pdf "CP")

;; 使用多个 tag（会包含任意一个 tag 的节点）
(my/org-roam-export-top-tagged-subtrees-to-pdf '("CP" "CF" "contest"))

;; 交互式输入多个 tag，用空格或逗号分隔
;; 例如：CP CF contest
#+end_src

**** 提取主节点
我这其实和 [[id:8e646f0b-aa8e-470b-9dd9-d70b8693dd3c][lazyblorg]] 干了差不多的事情，但是它没有基于 org-roam
然后让每个子树形成一篇博客，导出成 html
我这里却是平铺导出成 latex 加上页码链接

其实我之后也可以考虑复用这里的一些函数来做博客导出

说实话我没有看懂这里让多tag支持工作的宏

#+begin_src emacs-lisp
(defun my/org-roam-nodes-with-tag (tags &optional inheritp)
  "Return org-roam nodes where any of TAGS is locally defined (non-inherited).
TAGS can be a string (single tag) or a list of strings (multiple tags)."
  ;; (require 'org-roam)
  (let* ((tag-list (if (stringp tags) (list tags) tags))
         (or-clauses (cl-loop for i from 1 to (length tag-list)
                             collect `(= tags:tag ,(intern (format "$s%d" i)))))
         (where-clause (if (= (length or-clauses) 1)
                          (car or-clauses)
                        (cons 'or or-clauses)))
         (rows (apply #'org-roam-db-query
                     `[:select [nodes:file nodes:pos nodes:id]
                       :from nodes
                       :inner :join tags :on (= nodes:id tags:node_id)
                       :where ,where-clause]
                     tag-list))
         (result '())
         (seen-ids (make-hash-table :test 'equal)))
    (if inheritp
        (dolist (row rows result)
          (let ((id (nth 2 row)))
            (unless (gethash id seen-ids)
              (puthash id t seen-ids)
              (push (org-roam-node-from-id id) result))))
      (dolist (row rows result)
        (let ((file (nth 0 row))
              (pos  (nth 1 row))
              (id   (nth 2 row))
              node)
          (unless (gethash id seen-ids)
            (with-current-buffer (find-file-noselect file)
              (save-excursion
                (goto-char pos)
                (setq node (org-roam-node-at-point t))
                (setq local-tags
                      (if (eq pos 1)
                          org-file-tags
                        (org-get-tags nil t)))
                (when (seq-intersection tag-list local-tags)
                  (puthash id t seen-ids)
                  (push node result))))))))
      result))
#+end_src

**** 拉入节点子树
先通过 =my/org-roam-nodes-with-tag= 得到所有需要拉入的不重复的子树

拉入的时候需要统一标题层级

需要统一文件节点的形式

需要借鉴 fn:org-roam-refile
其实并不复杂，实现好了

#+begin_src emacs-lisp
(defun my/org-roam-extract-subtree (node)
  (let ((file (org-roam-node-file node))
        (pos  (org-roam-node-point node)))
    (with-temp-buffer
      (org-mode)
      (insert-file-contents file)
      (goto-char pos)
      (when (org-before-first-heading-p)
        (org-roam-demote-entire-buffer))
      (org-copy-subtree 1 nil t))))
#+end_src

然后可以用 fn:org-paste-subtree 进行粘贴

**** 重排序
然后根据某些规则安排顺序
可以从 org-roam 中直接导出这个 tag 的所有节点，来重新得到各个节点在这个文件中的锚点（大概可以通过查询 id 得到）

**** 添加反向链接
反向链接要需显示父标题链（文件标题+olp+节点标题）
其实子树节点也可以显示一下副标题链？

其实可以 join 一下同时查 id 和 title

#+begin_src emacs-lisp :tangle no
(defun my/org-roam-backlinks-of-id-old (id)
  "Return list of (SRC-ID TITLE)."
  (let* ((rows (org-roam-db-query
                [:select [source]
                 :from links
                 :where (and (= dest $s1) (= type "id"))]
                id))
         res)
    (dolist (row rows)
      (let* ((id (car row))
             (title (org-roam-node-title (org-roam-node-from-id id))))
        (message "%s" id)
        (push (list id title) res)))
    (nreverse res)))
#+end_src

#+begin_src emacs-lisp
(defun my/org-roam-backlinks-of-id (id)
  "Return list of (SRC-ID TITLE)."
  (let* ((tag-list (if (stringp my/org-roam-export-tag)
                       (list my/org-roam-export-tag)
                       my/org-roam-export-tag))
         (or-clauses (cl-loop for i from 2 to (1+ (length tag-list))
                             collect `(= tags:tag ,(intern (format "$s%d" i)))))
         (tag-where (if (= (length or-clauses) 1)
                       (car or-clauses)
                     (cons 'or or-clauses)))
         (where-clause (list 'and '(= links:dest $s1) '(= links:type "id") tag-where))
         (rows (apply #'org-roam-db-query
                     `[:select [links:source]
                       :from links
                       :inner :join tags :on (= links:source tags:node_id)
                       :where ,where-clause]
                     (cons id tag-list)))
         res)
    (dolist (row rows)
      (let* ((id (car row))
             (title (org-roam-node-title (org-roam-node-from-id id))))
        (push (list id title) res)))
    (-uniq (nreverse res))))
#+end_src

#+begin_src emacs-lisp
(defun my/org-roam-append-to-node-end (id file content)
  "在指定节点的末尾（而非文件末尾）追加内容"
  (save-excursion
    (goto-char (cdr (org-id-find-id-in-file id file)))
    ;; 移动到节点内容的末尾，但在下一个同级标题之前
    (goto-char (org-entry-end-position))
    ;; 向前移动一个字符，确保在节点内容末尾
    (backward-char 1)
    (end-of-line)
    (insert "\n" content)))
#+end_src

#+begin_src emacs-lisp
(defun my/org-insert-backlinks-section (id file)
  (let ((bl (my/org-roam-backlinks-of-id id)))
    (when bl
      (let ((content "\n- Backlinks\n"))
        (dolist (pair bl)
          (setq content (concat content (format "  - [[id:%s][%s]]\n" (car pair) (cadr pair)))))
        (message "Id: %s backlinks: %s" id content)
        (my/org-roam-append-to-node-end id file content)))))
#+end_src

***** TODO 在无法找到对应 id 也就是链接解析失败的时候会报错失败

**** 导出页码
最后支持一下页码导出功能
应该就是用 \pageref{sec:chapter_one} 这样的东西
但是，我怎么在导出前知道他生成的 lable ？ 能不能修改链接导出的方式？

fn:org-latex-link 理论上可以advice这个函数

正确的做法应该是做一些配置，需要深入了解一下

var:org-export-filter-link-functions 这是处理链接的函数表

他的页码是从正文开始算的页码，然后我的目录也占页码的，这如何解决？
让 var:org-latex-toc-command 设置目录用罗马数字就好了
#+begin_src emacs-lisp
(setq org-latex-toc-command "\\pagenumbering{roman}\n\\tableofcontents\n\\newpage\n\\pagenumbering{arabic}\n\n")
#+end_src

#+begin_src emacs-lisp
(defun my/org-latex-link-with-pageref (orig-fun link desc info)
  "为内部链接添加页码引用的 advice 函数"
  (let* ((type (org-element-property :type link))
         (result (funcall orig-fun link desc info)))
    ;; 只对 custom-id, fuzzy, id 类型的链接添加页码引用
    (if (member type '("custom-id" "fuzzy" "id"))
        (let ((destination
               (if (string= type "fuzzy")
                   (org-export-resolve-fuzzy-link link info 'latex-matrices)
                 (org-export-resolve-id-link link info))))
          ;; 确保目标存在且不是外部文件
          (if (and destination
                   (not (eq (org-element-type destination) 'plain-text))
                   (not (eq destination nil)))
              (let ((label (org-latex--label destination info t)))
                ;; 在原结果后添加页码引用
                (concat result "~(第\\pageref{" label "}页)"))
            result))
      result)))

(advice-add 'org-latex-link :around #'my/org-latex-link-with-pageref)
#+end_src

**** 主要导出函数

我不确定能不能拆成多个文件，ox-latex 似乎不支持这种功能，不想了

现在的问题是做不到自动多次编译，需要手动再编译一次（或两次）

#+begin_src emacs-lisp :tangle packages.el
(package! pyim)
#+end_src

#+begin_src emacs-lisp
;; -- org-roam: export top-tagged subtrees to PDF (headline hierarchy parent definition) --
;; (require 'org)
;; (require 'org-roam)
;; (require 'org-element)
;; (require 'seq)
;; (require 'cl-lib)
;; Configure org-mode to use listings for code export
(setq! org-latex-src-block-backend 'listings)

(setq! org-latex-listings-options
       '(("backgroundcolor" "\\color{backcolour}")
         ("commentstyle" "\\color{codegreen}")
         ("keywordstyle" "\\color{magenta}")
         ("numberstyle" "\\tiny\\color{codegray}")
         ("stringstyle" "\\color{codepurple}")
         ("basicstyle" "\\ttfamily\\footnotesize")
         ("breakatwhitespace" "false")
         ("breaklines" "true")
         ("captionpos" "b")
         ("keepspaces" "true")
         ("numbers" "left")
         ("numbersep" "5pt")
         ("showspaces" "false")
         ("showstringspaces" "false")
         ("showtabs" "false")
         ("tabsize" "2")
         ("frame" "single")
         ("rulecolor" "\\color{black}")))

(setq! org-latex-pdf-process
       '("latexmk -pdflatex=xelatex -pdf -interaction=nonstopmode -output-directory=%o %f"))

(defun my/org-roam-export-top-tagged-subtrees-to-pdf (tags &optional outfile)
  "Export all top-tagged org-roam headlines (by headline hierarchy) into a single PDF.
TAGS can be a string (single tag) or a list of strings (multiple tags).
Inserts each subtree, adds backlinks, TOC, and uses xelatex+ctex for CJK."
  (interactive "sTags (space-separated): ")
  (require 'ox-latex)
  (require 'org-roam)
  ;; Add language aliases for listings package
  (add-to-list 'org-latex-listings-langs '(cpp "C++"))
  (add-to-list 'org-latex-listings-langs '(c++ "C++"))

  (let ((tag-list (if (stringp tags)
                      (split-string tags "[ ,]+" t "[ \t\n\r]+")
                    tags)))
    (org-roam-db-sync)
    (setq my/org-roam-export-tag tag-list)
    (let ((file-name (make-temp-file (format "roam-export-%s-" (mapconcat 'identity tag-list "-"))))
          (top-nodes (my/org-roam-nodes-with-tag tag-list))
          (all-nodes (my/org-roam-nodes-with-tag tag-list t)))
      (with-temp-file file-name
        (org-mode)
        ;; Export header: Chinese + hyperref + TOC + numbered headings + optimized layout
        (insert (format "#+title: Roam Export (%s)\n" (mapconcat 'identity tag-list ", ")))
        (insert "#+options: toc:t num:t \\n:t\n")
        (insert "#+latex_class_options: [twocolumn]\n")
        (insert "#+latex_compiler: xelatex\n")
        ;; Basic Chinese support
        (insert "#+latex_header: \\usepackage[UTF8]{ctex}\n")
        ;; Enhanced code blocks with line numbers and syntax highlighting
        (insert "#+latex_header: \\usepackage{listings}\n")
        (insert "#+latex_header: \\usepackage{xcolor}\n")
        (insert "#+latex_header: \\usepackage{enumitem}\n")
        (insert "#+latex_header: \\usepackage{titlesec}\n")
        (insert "#+latex_header: \\definecolor{codegreen}{rgb}{0,0.6,0}\n")
        (insert "#+latex_header: \\definecolor{codegray}{rgb}{0.5,0.5,0.5}\n")
        (insert "#+latex_header: \\definecolor{codepurple}{rgb}{0.58,0,0.82}\n")
        (insert "#+latex_header: \\definecolor{backcolour}{rgb}{0.95,0.95,0.92}\n")
        ;; Compact spacing, fonts, and layout tweaks
        (insert "#+latex_header: \\renewcommand{\\normalsize}{\\fontsize{9}{9.5}\\selectfont}\n")
        (insert "#+latex_header: \\setlength{\\parindent}{0pt}\n")
        (insert "#+latex_header: \\setlength{\\parskip}{0pt plus 0.2em}\n")
        (insert "#+latex_header: \\setlist{topsep=0.3em,itemsep=0.2em,parsep=0em,partopsep=0em}\n")
        (insert "#+latex_header: \\titlespacing*{\\section}{0pt}{0.6em}{0.3em}\n")
        (insert "#+latex_header: \\titlespacing*{\\subsection}{0pt}{0.5em}{0.25em}\n")
        (insert "#+latex_header: \\titlespacing*{\\subsubsection}{0pt}{0.4em}{0.2em}\n")
        ;; Geometry must be last to avoid being overridden
        (insert "#+latex_header: \\usepackage[margin=0.3in,top=0.25in,bottom=0.5in,left=0.2in,right=0.2in]{geometry}\n\n")
        ;; Sort top-nodes by title in dictionary order (Chinese titles converted to pinyin)
        (setq top-nodes (sort top-nodes
                             (lambda (a b)
                               (string> (my/string-to-pinyin-for-sort (org-roam-node-title a))
                                       (my/string-to-pinyin-for-sort (org-roam-node-title b))))))
        (dolist (n top-nodes)
          (my/org-roam-extract-subtree n)
          (org-paste-subtree 2))

        (write-file file-name)

        (dolist (n all-nodes)
          (let ((id (org-roam-node-id n)))
            (my/org-insert-backlinks-section id file-name)))

        ;; Export to PDF
        (let ((outfile (or outfile (expand-file-name (format "roam-%s.pdf" (mapconcat 'identity tag-list "-")) default-directory))))
          (org-latex-export-to-pdf)
          (message "Exported PDF for tags %s. Buffer: %s" tag-list (buffer-name)))))))
#+end_src

**** 快捷键绑定
#+begin_src emacs-lisp
(map! :leader
      :desc "Roam export top-tagged subtrees to PDF"
      "n r e" #'my/org-roam-export-top-tagged-subtrees-to-pdf)
#+end_src

**** 一些问题

如果代码块有一些奇怪的属性，可能会出现导出错误
比如 =:exports both :results output=

标题需要根据拼音的字典序排序！用 pyim 的函数实现了

** HOLD 自动为 =:chat:= 标签添加 folded VISIBILITY

还未能正常工作

说实话可以用 =:ARCHIVE:= 标签平替

#+begin_src emacs-lisp :tangle no
(after! org
  (defun my/org-auto-fold-chat-headings ()
    "Automatically add VISIBILITY: folded property to headings with :chat: tag."
    (save-excursion
      (save-restriction
        (widen)
        (goto-char (point-min))
        (while (re-search-forward "^\\*+ " nil t)
          (when (org-at-heading-p)
            (let ((tags (org-get-tags nil t)))
              (when (member "chat" tags)
                (unless (string= (org-entry-get nil "VISIBILITY") "folded")
                  (org-entry-put nil "VISIBILITY" "folded")))))))))

  (defun my/org-add-visibility-on-tag-change ()
    "Add folded VISIBILITY when :chat: tag is added."
    (when (org-at-heading-p)
      (let ((tags (org-get-tags nil t)))
        (when (member "chat" tags)
          (unless (string= (org-entry-get nil "VISIBILITY") "folded")
            (org-entry-put nil "VISIBILITY" "folded")
            (org-cycle-hide-property-drawers 'overview))))))

  ;; 当标签改变时检查
  (add-hook 'org-after-tags-change-hook #'my/org-add-visibility-on-tag-change)
  
  ;; 打开文件时扫描整个文件
  (add-hook 'org-mode-hook 
            (lambda ()
              (run-with-idle-timer 0.1 nil #'my/org-auto-fold-chat-headings)))
  
  ;; 保存文件前自动添加
  (add-hook 'before-save-hook 
            (lambda ()
              (when (eq major-mode 'org-mode)
                (my/org-auto-fold-chat-headings)))))
#+end_src

** org-babel 配置

*** 让 lsp-mode 在 org-src-mode 下工作

[[https://tecosaur.github.io/emacs-config/config.html#lsp-support-src][tecosaur's Doom Emacs Configuration]]
在这里抄的

#+begin_src emacs-lisp
(cl-defmacro lsp-org-babel-enable (lang)
  "Support LANG in org source code block."
  (setq centaur-lsp 'lsp-mode)
  (cl-check-type lang string)
  (let* ((edit-pre (intern (format "org-babel-edit-prep:%s" lang)))
         (intern-pre (intern (format "lsp--%s" (symbol-name edit-pre)))))
    `(progn
       (defun ,intern-pre (info)
         (let ((file-name (->> info caddr (alist-get :file))))
           (unless file-name
             (setq file-name (make-temp-file "babel-lsp-")))
           (setq buffer-file-name file-name)
           (lsp-deferred)))
       (put ',intern-pre 'function-documentation
            (format "Enable lsp-mode in the buffer of org source block (%s)."
                    (upcase ,lang)))
       (if (fboundp ',edit-pre)
           (advice-add ',edit-pre :after ',intern-pre)
         (progn
           (defun ,edit-pre (info)
             (,intern-pre info))
           (put ',edit-pre 'function-documentation
                (format "Prepare local buffer environment for org source block (%s)."
                        (upcase ,lang))))))))

(defvar org-babel-lang-list
  '("go" "python" "ipython" "bash" "sh" "cpp"))

(dolist (lang org-babel-lang-list)
  (eval `(lsp-org-babel-enable ,lang)))

#+end_src

*** ob-C-stdin

[[https://github.com/cxa/ob-C-stdin/tree/main][GitHub]]
让 C/C++ 支持 ~:stdin <element-name>~

很好用，可以直接在笔记里跑样例了

#+begin_src emacs-lisp
(after! ob-C
  (defun org-babel-C-execute/filter-args (args)
    (when-let* ((params (cadr args))
                (stdin (cdr (assoc :stdin params)))
                (res (org-babel-ref-resolve stdin))
                (stdin (org-babel-temp-file "c-stdin-")))
      (with-temp-file stdin (insert res))
      (let* ((cmdline (assoc :cmdline params))
             (cmdline-val (or (cdr cmdline) "")))
        (when cmdline (setq params (delq cmdline params)))
        (setq params
              (cons (cons :cmdline (concat cmdline-val " <" stdin))
                    params))
        (setf (cadr args) params)))
    args)

  (with-eval-after-load 'ob-C
    (advice-add 'org-babel-C-execute :filter-args
                #'org-babel-C-execute/filter-args)))
#+end_src

** latex 集成
*** 添加 LaTeX 包

会在导出的时候自动加到文件里
#+begin_src emacs-lisp
(after! org
  (dolist (pkg '("amsmath" "amssymb" "mathtools" "mathrsfs"))
    (add-to-list 'org-latex-packages-alist `("" ,pkg t))))
#+end_src

*** 行间latex块背景色

[[https://stackoverflow.com/questions/69474043/emacs-org-mode-background-color-of-latex-fragments-with-org-highlight-latex-a][Emacs org mode: background color of latex fragments (with `org-highlight-latex-and-related`) : which variable to change?]]

#+begin_src emacs-lisp
(after! org-src
  (add-to-list 'org-src-block-faces
               '("latex" (:inherit default :extend t)))
  )
#+end_src

*** org-latex-preview
**** LaTeX 预览渲染进程设置

#+begin_src emacs-lisp
(setq org-preview-latex-default-process 'dvisvgm)
#+end_src

**** LaTeX 预览图像缩放
:PROPERTIES:
:CUSTOM_ID: latex-resize
:END:

[[https://karthinks.com/software/scaling-latex-previews-in-emacs/][Scaling Latex previews in Emacs | Karthinks]] 这篇文章和评论区帮了大忙了

#+begin_src emacs-lisp
(defun my/text-scale-adjust-latex-previews ()
  "Adjust the size of latex preview fragments when changing the buffer's text scale."
  (pcase major-mode
    ('latex-mode
     (dolist (ov (overlays-in (point-min) (point-max)))
       (if (eq (overlay-get ov 'category)
               'preview-overlay)
           (my/text-scale--resize-fragment ov))))
    ('org-mode
     (dolist (ov (overlays-in (point-min) (point-max)))
       (if (eq (overlay-get ov 'org-overlay-type)
               'org-latex-overlay)
           (my/text-scale--resize-fragment ov))))))

(defun my/text-scale--resize-fragment (ov)
  ;; 直接根据当前文本缩放设置图像的 :scale
  ;; 由于 org-format-latex-options 的 :scale 固定为 1.0，这里直接设置最终缩放
  (let* ((base-scale 1.0)  ; 基础缩放比例，可以调整
         (step (if (boundp 'text-scale-mode-step) text-scale-mode-step 1.2))
         (amount (if (boundp 'text-scale-mode-amount) text-scale-mode-amount 0))
         (factor (expt step amount))
         (new-scale (* base-scale factor)))
    ;; 更新display的scale
    (overlay-put
     ov 'display
     (cons 'image
           (plist-put
            (cdr (overlay-get ov 'display))
            :scale new-scale)))))

(add-hook 'text-scale-mode-hook #'my/text-scale-adjust-latex-previews)

;; 在LaTeX预览渲染后立即应用正确的缩放
(defun my/latex-preview-post-render (&rest _)
  "在LaTeX预览渲染后应用当前的文本缩放"
  (when (eq major-mode 'org-mode)
    (my/text-scale-adjust-latex-previews)))

;; 使用advice拦截LaTeX预览渲染函数
(after! org
  (advice-add 'org-latex-preview :after #'my/latex-preview-post-render))
#+end_src

***** TODO 在标题处按 RET 时也会 toggle latex 预览，此时预览跳出的大小没有被正确设置！
***** TODO 现在的设置没有随字体大小变化而变化，在字体调大之后预览会出现占不满行高的情况

*** evil-tex-mode in src-mode
不知道有什么用
#+begin_src emacs-lisp :tangle no
(add-hook! 'org-src-mode-hook
  (when (string= major-mode "latex-mode")
    (evil-tex-mode 1)))
#+end_src

** typst 集成

*** typst-ts-mode
#+begin_src emacs-lisp :tangle packages.el
(package! typst-ts-mode
  :recipe (:type git :host codeberg :repo "meow_king/typst-ts-mode"))
#+end_src

#+begin_src emacs-lisp
(use-package! typst-ts-mode
  :custom
  (typst-ts-watch-options "--open")
  ;; (typst-ts-mode-grammar-location (expand-file-name "tree-sitter/libtree-sitter-typst.so" user-emacs-directory))
  (typst-ts-enable-raw-blocks-highlight t)
  :config
  (keymap-set typst-ts-mode-map "C-c C-c" #'typst-ts-tmenu))
#+end_src

*** org-typst-advice
:PROPERTIES:
:CUSTOM_ID: org-typst-advice
:END:

#+begin_src emacs-lisp
(defvar org-typst-scale-ratio 180)
(defvar org-typst-debug nil
  "Enable debug messages for org Typst advice.")

(defun org-typst--debug (fmt &rest args)
  (when org-typst-debug
    (apply #'message (concat "[org-typst] " fmt) args)))

(defun org-create-formula-image--typst-advice (orig-fun string tofile options buffer &optional processing-type)
  "Advice for `org-create-formula-image' to add Typst support.

When PROCESSING-TYPE is 'latex and STRING is $ delimited, first try
compiling with Typst. If successful, return the SVG output directly.
Otherwise, fall back to the original LaTeX processing.

ORIG-FUN is the original function.
STRING, TOFILE, OPTIONS, BUFFER, and PROCESSING-TYPE are the original arguments."
  (org-typst--debug "Enter advice: processing-type=%S tofile=%S" processing-type tofile)
  (if (and (eq processing-type org-preview-latex-default-process)
           (numberp (string-match-p "\\`\\s-*\\$" string))
           (numberp (string-match-p "\\$\\s-*\\'" string)))
      (let* ((tmpdir temporary-file-directory)
             (typst-filebase (make-temp-name (expand-file-name "orgtypst" tmpdir)))
             (typst-file (concat typst-filebase ".typ"))
             (svg-file (concat typst-filebase ".svg"))
             (typst-content (replace-regexp-in-string "\\`\\s-*\\$\\s-*\\|\\s-*\\$\\s-*\\'" "" string))
             (normal-type (and (numberp (string-match-p "\\`\\s-*\\$" typst-content)) (numberp (string-match-p "\\$\\s-*\\'" typst-content))))
             (scale (plist-get options :scale))
             (fg-raw (plist-get options (if buffer :foreground :html-foreground)))
             (bg-raw (plist-get options (if buffer :background :html-background)))
             (fg (cond
                  ((null fg-raw) nil)
                  ((eq fg-raw 'default) nil)
                  ((stringp fg-raw) fg-raw)
                  (t nil)))
             (bg (cond
                  ((null bg-raw) nil)
                  ((eq bg-raw 'default) nil)
                  ((string= bg-raw "Transparent") "Transparent")
                  ((stringp bg-raw) bg-raw)
                  (t "Transparent"))))
        (org-typst--debug "Typst candidate: tmpdir=%S typst=%S svg=%S" tmpdir typst-file svg-file)
        (org-typst--debug "Scale=%S fg=%S bg=%S" scale fg bg)
        (condition-case err
            (progn
              (org-typst--debug "Writing Typst file...")
              (with-temp-file typst-file
                (let ((page-fill (cond
                                  ((or (null bg) (string= bg "Transparent")) "#none")
                                  (t (format "rgb(\"%s\")" bg))))
                      (margin (if normal-type 1 0)))
                  (insert (format "#set page(width: auto, height: auto, margin: %dpt, fill: %s)\n" margin page-fill)))
                (when fg
                  (insert (format "#set text(fill: rgb(\"%s\"))\n" fg)))
                (let ((real-content (if normal-type
                                        (replace-regexp-in-string "\\`\\s-*\\$\\s-*\\|\\s-*\\$\\s-*\\'" "" typst-content)
                                      (format "$ %s $" typst-content))))
                  (insert (format "#scale(x:%f*%d%%,y:%f*%d%%,reflow:true)[\n %s \n]" scale org-typst-scale-ratio scale org-typst-scale-ratio real-content))))
              (org-typst--debug "Typst file written: %s (len=%d)" typst-file (nth 7 (file-attributes typst-file)))
              (with-current-buffer (get-buffer-create "*typst-formula*")
                (let ((inhibit-read-only t))
                  (erase-buffer)
                  (insert-file-contents typst-file)))
              (org-typst--debug "Running typst compile...")
              (let* ((compile-buf (get-buffer-create "*typst-compile*"))
                     (exit-code (call-process "typst" nil compile-buf nil
                                              "compile" typst-file svg-file)))
                (org-typst--debug "Typst exit-code=%s svg-exists=%s" exit-code (file-exists-p svg-file))
                (when org-typst-debug
                  (org-typst--debug "Typst output:\n%s"
                                    (with-current-buffer compile-buf
                                      (buffer-substring-no-properties (point-min) (point-max)))))
                (if (and (eq exit-code 0) (file-exists-p svg-file))
                    (progn
                      (org-typst--debug "Typst success; copying %s -> %s" svg-file tofile)
                      (copy-file svg-file tofile 'replace)
                      (when (file-exists-p typst-file) (delete-file typst-file))
                      (when (file-exists-p svg-file) (delete-file svg-file))
                      (org-typst--debug "Typst cleanup done; returning %s" tofile)
                      tofile)
                  (org-typst--debug "Typst failed; cleaning up and falling back to LaTeX")
                  (when (file-exists-p typst-file) (delete-file typst-file))
                  (when (file-exists-p svg-file) (delete-file svg-file))
                  (funcall orig-fun string tofile options buffer processing-type))))
          (error
           (org-typst--debug "Error: %s" (error-message-string err))
           (when (file-exists-p typst-file) (delete-file typst-file))
           (when (file-exists-p svg-file) (delete-file svg-file))
           (org-typst--debug "Fallback to LaTeX due to error")
           (funcall orig-fun string tofile options buffer processing-type))))
    (org-typst--debug "Not a Typst candidate; using original function")
    (funcall orig-fun string tofile options buffer processing-type)))

(after! org
  (advice-add 'org-create-formula-image :around #'org-create-formula-image--typst-advice))
#+end_src


*** ox-typst
#+begin_src emacs-lisp :tangle packages.el
(package! ox-typst)
#+end_src

#+begin_src emacs-lisp
(use-package! ox-typst
  :after org)
#+end_src
** org-passwords.el

#+begin_src emacs-lisp
(setq org-passwords-file "~/org/passwords.gpg")
#+end_src

** 把一个 region 转换为 org-mode

参考 [[http://yummymelon.com/devnull/converting-a-markdown-region-to-org-revisited.html][nfdn: Converting a Markdown Region to Org Revisited]]

#+begin_src emacs-lisp
(defun my-md-to-org-region (start end)
  "Convert region from markdown to org"
  (interactive "r")
  (shell-command-on-region start end "pandoc -f markdown -t org" t t))
#+end_src

** org-transclusion

#+begin_src emacs-lisp :tangle packages.el
(package! org-transclusion)
#+end_src

#+begin_src emacs-lisp
(with-eval-after-load 'org-transclusion
  (add-to-list 'org-transclusion-extensions 'org-transclusion-indent-mode)
  (require 'org-transclusion-indent-mode))
;; (use-package! org-transclusion
;;               :after org
;;               :init
;;               (map!
;;                :map global-map "<f12>" #'org-transclusion-add
;;                :leader
;;                :prefix "n"
;;                :desc "Org Transclusion Mode" "t" #'org-transclusion-mode))


(use-package! org-transclusion
  :after org
  :init
  (map!
   :map org-mode-map
   :localleader
   :prefix ("u" . "transclUde")
   :desc "Mode" "t" #'org-transclusion-mode
   :desc "Deactivate" "D" #'org-transclusion-deactivate
   :desc "Refresh" "f" #'org-transclusion-refresh

   ;; Adding
   :desc "Add" "a" #'org-transclusion-add
   :desc "Add all" "A" #'org-transclusion-add-all
   :desc "Add From link" "l" #'org-transclusion-make-from-link

   ;; Removing
   :desc "Remove all" "r" #'org-transclusion-remove
   :desc "Remove all" "R" #'org-transclusion-remove-all

   ;; Live sync
   :desc "Start live sync" "s" #'org-transclusion-live-sync-start
   :desc "Stop live sync" "S" #'org-transclusion-live-sync-exit

   ;; Navigating
   :desc "Open source" "o" #'org-transclusion-move-to-source

   ;; Subtrees
   :desc "Demote Subtree" "h" #'org-transclusion-demote-subtree
   :desc "Promote Subtree" "l" #'org-transclusion-promote-subtree)
  :config
  (add-hook 'before-save-hook #'org-transclusion-refresh))

#+end_src

** TODO 在 roam 链接上按 K lookup 打开临时预览窗口

预览窗口是指按 q 退出（能回到上一层预览窗口就更好了）

还有比如说在侧边打开而不是替换原窗口

** ox-hugo 
#+begin_src emacs-lisp :tangle no
(after! org
  (setq org-id-extra-files (append (directory-files-recursively org-roam-directory "\.org$")
                                    (list (expand-file-name "config.org" doom-user-dir)))))
#+end_src

#+begin_src elisp :tangle packages.el
(package! org-roam-hugo
  :recipe (:local-repo "org-roam-hugo"))
#+end_src

** Deft :ARCHIVE:
我觉得完全用不到，这不适合和 org-roam 配合使用

#+begin_src emacs-lisp :tangle no
(after! org
  (setq deft-recursive t
        deft-use-filter-string-for-filename t
        deft-default-extension "org"
        deft-directory org-directory))
#+end_src

** org-supertag :ARCHIVE:
无法正常工作
#+begin_src emacs-lisp :tangle no
(package! org-supertag
  :recipe (:host github :repo "yibie/org-supertag"))
(package! deferred)
(package! epc)
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package! org-supertag
  :after org
  :config
  (org-supertag-setup))

(setq org-supertag-sync-directories '("~/org")) ;; 注意这里不能直接写 org-directory，格式是不一样的，直接写会变成 126 error code
#+end_src

** valign 表格对齐 :ARCHIVE:

不使用 org-modern 的表格美化，改用 valign

#+begin_src emacs-lisp :tangle no
(package! valign)
#+end_src

#+begin_src emacs-lisp :tangle no
(add-hook 'org-mode-hook #'valign-mode)
(after! org
  (setq valign-fancy-bar t
        org-modern-table nil))
#+end_src



* LaTeX editing

#+begin_src emacs-lisp
(setq +latex-viewers '(zathura))
#+end_src

* Input Method & 中文支持

我之前本来还想搞分词配置的，结果发现我完全没有这个的需求

** rime config

#+begin_src emacs-lisp
(after! rime
  (setq rime-translate-keybindings
        '("C-h" "C-f" "C-b" "C-n" "C-p" "<tab>" "C-a" "C-s" "C-c")))
#+end_src

** cnfonts

不好看啊，中英文等宽一点都不协调

#+begin_src emacs-lisp :tangle no
(package! cnfonts)
#+end_src

#+begin_src emacs-lisp :tangle no
(after! org
  (require 'cnfonts)
  (cnfonts-mode 1)
  )
(setq! cnfonts-use-face-font-rescale t)
#+end_src

事实上即使用了这个东西也做不到完美对齐

** DONE vertico 拼音搜索集成

已经在 rime module 里实现了

** 输入法切换快捷键 :ARCHIVE:

将 `toggle-input-method` 从默认的 `C-\` 改为 `C-TAB`，减少右手负担
#+begin_src emacs-lisp :tangle no
(map! [C-tab] #'toggle-input-method)
#+end_src

但是在一些特殊情况下这个快捷键会已经被占用，有点难受
比如说 org-roam-find 的 minibuffer 里
调用的是 fn:file-cache-minibuffer-complete

现在换用 charybdis 键盘之后 \ 离小拇指的距离变近了，就不需要这个配置了

* evil 相关

** insert mode 中 C-n/p 设置为上下行

因为它本来是补全相关的，所以只要改 corfu 的设置就行了

现在我如果要手动唤起补全，就用 C-SPC
然后在唤起 popup 之后用 C-n/p 切换上下待选项依然是可以用的！

#+begin_src emacs-lisp
(after! corfu
  (map! :map corfu-mode-map
        :i "C-n" #'next-line
        :i "C-p" #'previous-line))
#+end_src

** insert mode 中 C-h/l 重新设计

=C-h= 退格， =C-l= 撤回退格操作

#+begin_src emacs-lisp
;; 创建一个变量来存储被删除的字符
(defvar my/evil-insert-deleted-chars nil
  "Stack of characters deleted by C-h in evil insert mode.")

(defun my/evil-insert-backspace ()
  "Delete backward char and save it for potential undo with C-l."
  (interactive)
  (when (> (point) (point-min))
    (let ((char (char-before)))
      (when char
        ;; 将删除的字符推入栈
        (push char my/evil-insert-deleted-chars)
        ;; 删除字符
        (delete-backward-char 1)))))

(defun my/evil-insert-undo-backspace ()
  "Undo the last backspace operation by reinserting the deleted character."
  (interactive)
  (when my/evil-insert-deleted-chars
    ;; 从栈中弹出字符并插入
    (let ((char (pop my/evil-insert-deleted-chars)))
      (insert char))))

;; 清空删除字符栈当退出 insert mode 时
(defun my/evil-insert-clear-deleted-chars ()
  "Clear the deleted characters stack."
  (setq my/evil-insert-deleted-chars nil))

;; 在退出 insert mode 时清空栈
(add-hook 'evil-insert-state-exit-hook #'my/evil-insert-clear-deleted-chars)

;; 绑定按键 - 使用 after! 确保优先级
(map! :i "C-h" #'my/evil-insert-backspace
      :i "C-l" #'my/evil-insert-undo-backspace)

;; 在 org-mode 中也确保生效（需要使用 evil-org-mode-map）
(after! evil-org
  (map! :map evil-org-mode-map
        :i "C-h" #'my/evil-insert-backspace
        :i "C-l" #'my/evil-insert-undo-backspace))
#+end_src

*** TODO minibuffer 支持

* VCS

** magit
#+begin_src emacs-lisp :tangle no
(setq! git-commit-major-mode #'org-mode)
#+end_src

注意当这里设为 org-mode 的时候，无法正常高亮！

** orgit
#+begin_src emacs-lisp
;; (setq! orgit-log-save-arguments t)
#+end_src

** jujutsu integration
我的配置都放在了 [[doom-module:tools majutsu]]


#+begin_src emacs-lisp
(setq! majutsu-log-signature
       '[:call 'format_short_signature [:author]])


(setq! majutsu-message-input-method 'script)
#+end_src

* Program
** Languages
*** C/C++

我会把大部分配置写在 CP/cpp 模块里

**** 缩进

#+begin_src emacs-lisp
;; tree-sitter 模式的缩进设置
(setq c-ts-mode-indent-offset 4)
#+end_src

**** 运行与调试

我希望使用 gdb 调试，怎么写 dape 配置？

#+begin_src emacs-lisp
(after! dape
  (add-to-list 'dape-configs
	       `(debugpy-flask
	         modes (python-mode jinja2-mode)
	         command "python"
	         command-args ["-m" "debugpy.adapter" "--host" "0.0.0.0" "--port" :autoport]
	         port :autoport
	         :type "python"
	         :request "launch"
	         :module "flask"
	         :args ["--app" "src" "run" "--no-debugger" "--no-reload"]
	         :console "integratedTerminal"
	         :showReturnValue t
	         :justMyCode nil
	         :jinja t
	         :cwd dape-cwd-fn))


  (defun my/dape-contest--buffer-src (config)
    (or (buffer-file-name (or (plist-get config :buffer) (current-buffer)))
        (user-error "当前 buffer 还没有保存成文件")))

  (defun my/dape-contest--cwd (config)
    (or (dape-config-get config :cwd)
        (dape-cwd)))

  (defun my/dape-contest--binary (config)
    (let* ((src  (my/dape-contest--buffer-src config))
           (root (my/dape-contest--cwd config))
           (prob (file-name-base src))
           (candidates
            (list (expand-file-name (format "build/%s.debug" prob) root)
                  (expand-file-name (format "build/%s" prob) root)
                  (expand-file-name prob root)
                  (expand-file-name "a.out" root))))
      (or (seq-find #'file-exists-p candidates)
          (user-error "没找到可执行文件，先在 %s 里运行 `make PROB=%s`"
                      root prob))))

  (defun my/dape-contest--prep (config)
    (let* ((src (my/dape-contest--buffer-src config))
           (prob (file-name-base src))
           (default-directory (my/dape-contest--cwd config))
           ;; 如果你只用简化版 Makefile，把命令改成 make PROB=%s DEBUG=1
           (cmd (if (file-exists-p (expand-file-name "Makefile" default-directory))
                    (format "make debug PROB=%s" prob)
                  nil)))
      (when cmd
        (let ((status (call-process-shell-command cmd nil "*dape-make*" t)))
          (unless (zerop status)
            (user-error "构建失败，查看 *dape-make* buffer"))))))

  (add-to-list 'dape-configs
               '(contest-gdb
                 modes (c-mode c-ts-mode c++-mode c++-ts-mode)
                 ensure my/dape-contest--buffer-src
                 fn (lambda (config)
                      (let ((program (my/dape-contest--binary config))
                            (cwd (my/dape-contest--cwd config)))
                        (plist-put (plist-put config :program program) :cwd cwd)))
                 :pre-function my/dape-contest--prep
                 command "gdb"
                 command-args ("--interpreter=dap")
                 :type "gdb"
                 :request "launch"
                 :stopAtBeginningOfMainSubprogram nil
                 :args []))
  )
#+end_src

*** Python

**** lsp-pyright config
切换到 basedpyright

#+begin_src emacs-lisp
(setq! lsp-pyright-langserver-command "basedpyright")
#+end_src

 
**** dape config
自带的 debugpy 配置不能正常工作。。。

**** 缩进示例
#+begin_src emacs-lisp :tangle no
(add-hook 'python-mode-hook
            (lambda ()
              (setq-local tab-width 4)
              (setq-local indent-tabs-mode nil)))
#+end_src

** lsp-mode config

#+begin_src emacs-lisp
(after! lsp-mode
  (setq lsp-idle-delay 0.5
        lsp-log-io nil
        lsp-completion-provider :capf
        lsp-enable-file-watchers nil
        lsp-enable-folding nil
        lsp-enable-text-document-color nil
        lsp-enable-on-type-formatting nil
        lsp-enable-snippet nil
        lsp-enable-symbol-highlighting t        ; 启用符号高亮
        lsp-enable-links nil
        lsp-lens-enable t
        lsp-headerline-breadcrumb-enable t))

;; LSP UI settings for better performance
(after! lsp-ui
  (setq lsp-ui-doc-enable t                     ; 启用文档显示
        lsp-ui-doc-delay 0.3                    ; 文档显示延迟
        lsp-ui-doc-position 'at-point           ; 文档显示位置
        lsp-ui-doc-show-with-cursor nil         ; 光标处显示文档
        lsp-ui-doc-show-with-mouse t            ; 鼠标悬停显示文档

        lsp-ui-sideline-enable t                ; 启用侧边栏
        lsp-ui-sideline-show-diagnostics t      ; 显示诊断信息
        lsp-ui-sideline-show-hover nil          ; 不显示hover信息
        lsp-ui-sideline-show-code-actions t     ; 显示代码操作
        lsp-ui-sideline-update-mode 'line       ; 只在当前行更新
        lsp-ui-sideline-delay 0.1               ; 减少延迟
        lsp-ui-sideline-diagnostic-max-lines 3  ; 每个诊断最多显示行数
        lsp-ui-sideline-diagnostic-max-line-length 100 ; 最大行长度

        lsp-ui-peek-enable t                    ; 启用peek功能
        lsp-ui-imenu-enable t)                  ; 启用imenu集成
  )
#+end_src

** claude-code-ide.el

#+begin_src emacs-lisp :tangle packages.el
(package! claude-code-ide
  :recipe (:host github :repo "manzaltu/claude-code-ide.el"))
#+end_src

** codex-cli


#+begin_src emacs-lisp :tangle packages.el
(package! codex-cli)
#+end_src

#+begin_src emacs-lisp
(use-package! codex-cli
  ;; For MELPA: :ensure t
  ;; For GitHub (Emacs 29+):
  ;; :vc (:fetcher github :repo "bennfocus/codex-cli.el")
  :bind (("C-c c t" . codex-cli-toggle)
         ("C-c c s" . codex-cli-start)
         ("C-c c q" . codex-cli-stop)
         ("C-c c Q" . codex-cli-stop-all)
         ("C-c c p" . codex-cli-send-prompt)
         ("C-c c r" . codex-cli-send-region)
         ("C-c c f" . codex-cli-send-file)
         ;; Show-all layout + paging
         ("C-c c a" . codex-cli-toggle-all)
         ("C-c c n" . codex-cli-toggle-all-next-page)
         ("C-c c b" . codex-cli-toggle-all-prev-page))
  :init
  (setq codex-cli-executable "codex"
        codex-cli-terminal-backend 'vterm
        codex-cli-side 'right
        codex-cli-width 90))
#+end_src

** copilot.el

#+begin_src emacs-lisp :tangle packages.el
(package! copilot
  :recipe (:host github :repo "copilot-emacs/copilot.el" :files ("*.el")))
#+end_src


#+begin_src emacs-lisp
;; accept completion from copilot and fallback to company
(use-package! copilot
  :hook (prog-mode . copilot-mode)
  :bind (:map copilot-completion-map
              ("<tab>" . 'copilot-accept-completion)
              ("TAB" . 'copilot-accept-completion)
              ;; ("C-TAB" . 'copilot-accept-completion-by-word)
              ;; ("C-<tab>" . 'copilot-accept-completion-by-word)

              ;; ;; Accept completions (Fish-shell inspired, no conflicts)
              ;; ("<right>" . 'copilot-accept-completion)
              ;; ("C-f" . 'copilot-accept-completion)

              ;; ;; Word-by-word acceptance
              ;; ("M-<right>" . 'copilot-accept-completion-by-word)
              ;; ("M-f" . 'copilot-accept-completion-by-word)

              ;; ;; Line-by-line and navigation
              ;; ("C-e" . 'copilot-accept-completion-by-line)
              ;; ("<end>" . 'copilot-accept-completion-by-line)
              ;; ("M-n" . 'copilot-next-completion)
              ;; ("M-p" . 'copilot-previous-completion)
              ;; ("C-g" . 'copilot-clear-overlay)
              )
  :config
  (setq copilot-indent-offset-warning-disable t)
  ;; (add-to-list 'copilot-indentation-alist '(emacs-lisp-mode 2))

  ;; Enable only in insert state for Evil users
  (when (modulep! :editor evil)
    (setq copilot-enable-predicates '(evil-insert-state-p)))

  ;; Disable in problematic modes
  (add-to-list 'copilot-disable-predicates
               (lambda () (member major-mode '(shell-mode eshell-mode term-mode
                                               vterm-mode comint-mode)))))
#+end_src

*** 遇到的一些小问题
[[https://github.com/copilot-emacs/copilot.el/issues/312][copilot-emacs/copilot.el#312 Warning (copilot): copilot--infer-indentation-of...]]
这个问题主要来自一些模式下 copilot 不能正确推断缩进，这个时候需要我们自己手动配置一下，或者干脆禁用掉这个警告

corfu 的补全可能会覆盖上这个自动上屏的 copilot 的补全，而 company 生态里有 company-box 可以解决这个问题

有一些信息来源说有 company 依赖，实际上是没有的
[[https://emacs-china.org/t/copilot/20348/20?u=0wd0][Copilot 非官方插件 - #20，来自 zerol - Emacs-general - Emacs China]]

** corfu

#+begin_src emacs-lisp
;;; Corfu configuration
(after! corfu
  (setq corfu-auto t                    ; Enable auto completion
        corfu-auto-delay 0.0            ; Balanced performance
        corfu-auto-prefix 2             ; Minimum prefix length
        corfu-cycle t                   ; Enable cycling
        +corfu-want-tab-prefer-expand-snippets t))
#+end_src

** treesit.el

#+begin_src emacs-lisp
(setq treesit-font-lock-level 4)
#+end_src

* Misc

是否解析符号链接
#+begin_src emacs-lisp
(setq! find-file-visit-truename t)
#+end_src

缩进风格
#+begin_src emacs-lisp
(setq! indent-tabs-mode nil)
(setq! tab-width 4)
#+end_src

** bibilo 模块设置
#+begin_src emacs-lisp
(setq! citar-bibliography '("/home/disk/Books/mybib.bib")
       citar-open-entry-function 'citar-open-entry-in-zotero)

(map!
 :map org-mode-map
 :localleader
 (:prefix ("C" . "Citar")
          (:prefix ("i" . "insert")
           :desc "Insert reference" "r" #'citar-insert-reference
           :desc "Insert citation" "c" #'citar-insert-citation
           :desc "Insert bibtex" "b" #'citar-insert-bibtex
           :desc "Insert keys" "k" #'citar-insert-keys
           )
          (:prefix ("o" . "open")
           :desc "Open citar" "o" #'citar-open
           :desc "Open files" "f" #'citar-open-files
           :desc "Open notes" "n" #'citar-open-notes
           :desc "Open note directly" "N" #'citar-open-note
           :desc "Open links" "l" #'citar-open-links
           :desc "Open entry in zotero" "e" #'citar-open-entry
           )
          ))

(after! org
  (require 'citar-org)
  (require 'citar-org-roam))

(map! :map org-mode-map
      :localleader
      :prefix ("m" . "org-roam")
      "c" #'citar-org-roam-open-current-refs)
;; 这个绑定在 citar 加载前不可用，之后需要改改

;; 下面是 citar-map 里的默认绑定，我不知道这个 keymap 原来是用在哪里的

;; RET citar-run-default-action
;; a   citar-add-file-to-library
;; r   citar-copy-reference

;; R   citar-insert-reference
;; b   citar-insert-bibtex
;; c   citar-insert-citation
;; k   citar-insert-keys
;; o   citar-open
;; e   citar-open-entry
;; f   citar-open-files
;; l   citar-open-links
;; n   citar-open-notes

;; 看源码看到的函数
;; citar-open-note
;;
#+end_src

** indent-bars

如果 =indent-bars-starting-column= 为 0，会在 org-mode 的 latex 片段的前面一个空格显示竖线！

#+begin_src emacs-lisp
(after! indent-bars
  (setq indent-bars-treesit-support t
        indent-bars-starting-column nil))
#+end_src

** consult.el

live preview

来自官方文档
#+begin_src emacs-lisp
(after! consult
  (consult-customize
   consult-ripgrep consult-git-grep consult-grep consult-man
   consult-bookmark consult-recent-file consult-xref
   consult--source-bookmark consult--source-file-register
   consult--source-recent-file consult--source-project-recent-file
   ;; my/command-wrapping-consult    ;; disable auto previews inside my command
   :preview-key '(:debounce 0.4 any) ;; Option 1: Delay preview
   ;; :preview-key "M-."             ;; Option 2: Manual preview
   ))
#+end_src

** nov.el

epub 支持

#+begin_src emacs-lisp :tangle packages.el
(package! nov)
#+end_src

#+begin_src emacs-lisp
(use-package! nov
  :mode ("\\.epub\\'" . nov-mode)
  :config
  (setq nov-save-place-file (concat doom-cache-dir "nov-places")))
#+end_src

** telega.el

telegram client for emacs

#+begin_src emacs-lisp :tangle packages.el
;; (package! company)
(package! telega)
#+end_src

#+begin_src emacs-lisp
(setq! telega-server-libs-prefix "/usr")
(use-package! telega
  :commands (telega)
  :defer t
  :init
  (unless (display-graphic-p) (setq telega-use-images nil))
  :config
  (define-key global-map (kbd "C-c t") telega-prefix-map)
  ;; (setq telega-proxies
  ;;       (list '(:server "127.0.0.1" :port 1086 :enable t
  ;;               :type (:@type "proxyTypeSocks5"))))
  (set-popup-rule! "^\\*Telega Root"
    :side 'right :size 100 :quit nil :modeline t)
  (set-popup-rule! "^◀\\(\\[\\|<\\|{\\).*\\(\\]\\|>\\|}\\)"
    :side 'right :size 100 :quit nil :modeline t)
  (telega-mode-line-mode 1))
#+end_src

** IRC config

#+begin_src emacs-lisp :tangle no
(setq! circe-network-options
      '(("Libera Chat"
         :tls t
         :nick "oWDo"
         :sasl-username "my-nick"
         :sasl-password "my-password"
         :channels ("#emacs-circe")
         )))
#+end_src

** solar.el

#+begin_src emacs-lisp
(setq! calendar-latitude 30.29365
       calendar-longitude 120.16142)
#+end_src

** cal-china-x
#+begin_src emacs-lisp :tangle packages.el
(package! cal-china-x)
#+end_src

#+begin_src emacs-lisp
(require 'cal-china-x)
(setq! mark-holidays-in-calendar t)
(setq! cal-china-x-important-holidays cal-china-x-chinese-holidays)
(setq! cal-china-x-general-holidays '((holiday-lunar 1 15 "元宵节")))
(setq! calendar-holidays
      (append cal-china-x-important-holidays
              cal-china-x-general-holidays
              ))
#+end_src

** bookmark+

#+begin_src emacs-lisp :tangle packages.el
(package! bookmark+)
#+end_src

#+begin_src emacs-lisp
(after! org
  (require 'bookmark+))
#+end_src

** Open at Point

#+begin_src emacs-lisp
(defvar my/last-editor nil
  "Last editor used to open file at point.")

(defun my/open-at-point-with (editor)
  "Open current file at current line and column with EDITOR."
  (when-let* ((file (buffer-file-name))
              (line (line-number-at-pos))
              (col (current-column)))
    (setq my/last-editor editor)
    (pcase editor
      ("Helix"
       (start-process "helix" nil "kitty" "helix" (format "%s:%d:%d" file line col)))
      ("VSCode"
       (start-process "code" nil "code" "-g" (format "%s:%d:%d" file line (1+ col))))
      ("Zed"
       (start-process "zed" nil "zeditor" (format "%s:%d:%d" file line (1+ col))))
      ("Nvim"
       (let ((nvim-socket "/tmp/nvim-emacs.sock"))
         (if (file-exists-p nvim-socket)
             (start-process "nvim" nil "nvim" "--server" nvim-socket
                            "--remote-send"
                            (format ":e +call\\ cursor(%d,%d) %s<CR>" line (1+ col) file))
           (start-process "nvim" nil "kitty" "nvim" "--listen" nvim-socket
                          (format "+call cursor(%d,%d)" line (1+ col)) file)))))))

;; unused
(defun my/open-at-point ()
  "Open current file at current line and column with external editor."
  (interactive)
  (let ((editor (completing-read "Choose editor: "
                                 '("Helix" "VSCode" "Nvim" "Zed"))))
    (my/open-at-point-with editor)))

(defun my/open-at-point-last ()
  "Open current file with last used editor."
  (interactive)
  (if my/last-editor
      (my/open-at-point-with my/last-editor)
    (my/open-at-point)))

(defun my/open-at-point-helix ()
  "Open current file with Helix."
  (interactive)
  (my/open-at-point-with "Helix"))

(defun my/open-at-point-vscode ()
  "Open current file with VSCode."
  (interactive)
  (my/open-at-point-with "VSCode"))

(defun my/open-at-point-nvim ()
  "Open current file with Nvim."
  (interactive)
  (my/open-at-point-with "Nvim"))

(defun my/open-at-point-zed ()
  "Open current file with Zed."
  (interactive)
  (my/open-at-point-with "Zed"))
#+end_src

#+begin_src emacs-lisp
(map! :leader
      :prefix ("o" . "open")
      :n "O" #'my/open-at-point
      :n "o" #'my/open-at-point-last
      :n "h" #'my/open-at-point-helix
      :n "v" #'my/open-at-point-vscode
      :n "n" #'my/open-at-point-nvim
      :n "z" #'my/open-at-point-zed)
#+end_src

* Calendar (khalel)
#+begin_src elisp :tangle packages.el
(package! khalel)
#+end_src

#+begin_src elisp
(use-package! khalel
  :after org
  :config
  (khalel-add-capture-template))
#+end_src

* LLM (gptel)

** config
#+begin_src emacs-lisp
(setq! gptel-default-mode #'org-mode)
#+end_src

** api-keys
#+begin_src emacs-lisp
(defvar aihubmix-api-key
  (or (getenv "AIHUBMIX_API_KEY") 
      "")
  "AiHubMix API key.
https://aihubmix.com/
好歹也是推广了，给个优惠不过分吧
")
#+end_src

** tool functions
#+begin_src emacs-lisp
(defmacro gptel-header+ (&rest kvs)
  "Build a :header function with Authorization plus extra key-value forms.
KVS elements are of the form (KEY VALUE-FORM). VALUE-FORM is evaluated at request time."
  `(lambda ()
     (let ((key (gptel--get-api-key)))
       (delq nil
             (append
              (when key (list (cons "Authorization" (concat "Bearer " key))))
              (list
               ,@(mapcar (lambda (kv)
                           `(let ((v ,(cadr kv)))
                              (when v (cons ,(car kv) v))))
                         kvs)))))))

;; 如果只需要静态常量（编译/加载时确定）
;; 这种宏在加载时就把常量“拼接”好：
(defmacro gptel-static-header+ (&rest pairs)
  `(lambda ()
     (let ((key (gptel--get-api-key)))
       (append
        (when key (list (cons "Authorization" (concat "Bearer " key))))
        ',pairs))))

#+end_src

** backend
#+begin_src emacs-lisp
(setq! gptel-backend
      (gptel-make-openai "AiHubMix"
        :host "api.aihubmix.com"
        :endpoint "/v1/chat/completions"
        :key 'aihubmix-api-key
        :stream t
        :header (gptel-header+
                 ("APP-Code"       "MLTG2087") ;这是在白嫖 cherry-studio 的优惠码
                 ;; 下面是示例，最近写宏写爽了
                 ;; ("X-Org-ID"      "42")                         
                 ;; ("X-Trace"       (format-time-string "%s")   
                 ;; ("X-Proxy"       (getenv "HTTP_PROXY")
                 ;; ("X-Proxy"       (getenv "HTTP_PROXY")
                 )       
        :models '(
                  (gpt-5      :capabilities (media tool json url))
                  (gpt-4o      :capabilities (media tool json url))
                  (gpt-4o-mini :capabilities (media tool json url)))))

(setq! gptel-model 'gpt-5)
#+end_src

* org-capture configs for Project Notes 

基于 dir-locals 的 org-capture 配置的优势在于：完全不用担心按键冲突，同一个键对不同的项目可以有不同的跳转效果
我甚至可以选择让他在某些目录无视 base-templates

注意，他会无视软连接！！！
如果 /home/disk/Dev 有一个软连接到 ~/Dev
不能写 ~/Dev 只能写原本的链接

#+begin_src elisp 
(require 'org-roam) ;; 这里的确没办法，如果要在 capture 里用 org-roam-node-fined 就得先加载，不然打开的第一个 buffer 得不到正确的 templates
(defvar my/org-capture-base-templates
  '(("r" "org-roam capture" entry #'org-roam-node-find "* %u %?\n%i\n%a" :prepend t)
    ;; ("t" "Task" entry (file "~/org/inbox.org") "* TODO %?")
    )
  "Fallback templates used when no directory-specific override exists.")

(defun my/org--merge-template (template)
  "Return base templates with TEMPLATE replacing any entry with the same key."
  (let ((key (car template)))
    (cons template
          (cl-remove-if (lambda (tpl) (equal (car tpl) key))
                        (copy-tree my/org-capture-base-templates)))))

(defun my/org-register-capture-dir (dir template)
  "Associate DIR with TEMPLATE via dir-local variables for org-capture."
  (let* ((abs-dir (file-name-as-directory (expand-file-name dir)))
         (class (intern (concat "my/org-" (md5 abs-dir))))
         (templates (my/org--merge-template template)))
    (dir-locals-set-class-variables
     class
     `((nil . ((org-capture-templates . ,templates)))))
    (dir-locals-set-directory-class abs-dir class)
    class))
  #+end_src
  
** examples
#+begin_src elisp :tangle no
(my/org-register-capture-dir
  "~/work/projectA"
  '("r" "ProjectA Reading"
    entry (file "~/work/projectA/notes.org")
    "* TODO %? :projA:"))

 (my/org-register-capture-dir
  "~/work/projectB"
  '("r" "ProjectB Reading"
    entry (file+headline "~/work/projectB/read.org" "Inbox")
    "* TODO %? :projB:"))
#+end_src

** magit
#+begin_src elisp
(my/org-register-capture-dir
 "/home/_WD_/.config/emacs/.local/straight/repos/magit"
 '("i" "magit dev notes inbox" entry (id "823e85ea-5028-4c57-bfca-b7c76bcf0f9a") "* %?\n%a\n"))
#+end_src

** jj
#+begin_src elisp
(my/org-register-capture-dir
 "/home/disk/Dev/jj"
 '("i" "jujutsu dev notes inbox" entry (id "c5b88ac7-c03b-4f60-a5b1-c2b01465b21d") "* %?\n%a\n"))
#+end_src

previous version
#+begin_src elisp :tangle no
(dir-locals-set-class-variables
 'jj-proj
 '((nil . ((org-capture-templates . (("j" "jujutsu dev notes" entry (id "c569d17b-0044-4029-bb28-426332d84f0d") "* %?\n%i\n%a" :prepend t)))))))

(dir-locals-set-directory-class
 (expand-file-name "/home/disk/Dev/jj/") 'jj-proj)
#+end_src

** majutsu

#+begin_src elisp
(my/org-register-capture-dir
 "~/.config/emacs/.local/straight/repos/majutsu"
 '("i" "majutsu dev notes inbox" entry (id "37acfc0e-808a-4952-9289-a71f21d58047") "* %?\n%a\n" :prepend t))
#+end_src

** hlissner/dotfiles
#+begin_src elisp
(my/org-register-capture-dir
 "/home/disk/Dev/hlissner-dotfiles"
 '("i" "hlissner dotfiles notes inbox" entry (id "c83bdc2f-a656-4e6d-baa0-df28db85d3fc") "* %?\n%a\n" :prepend t))
#+end_src


* Org-mode footnote hover preview :ATTACH:
:PROPERTIES:
:ID:       0908f342-a68a-4358-93da-70f99e7bc20c
:END:

只要窗口不要特别小就不会有问题

后续想要改一下 line wrap 的适配

在 footnote 那边的链接该显示原文的相关内容，或者不搞预览，暂时不管

#+begin_src emacs-lisp :tangle no
;;; Org-mode footnote hover preview - Enhanced implementation inspired by lsp-ui-doc
(use-package! posframe :defer t)

(defgroup org-footnote-preview nil
  "Preview footnotes in org-mode."
  :group 'org)

(defcustom org-footnote-preview-use-childframe t
  "Whether to use child-frame for footnote preview.
If nil, use posframe instead."
  :type 'boolean
  :group 'org-footnote-preview)

(defcustom org-footnote-preview-position 'at-point
  "Position for footnote preview."
  :type '(choice (const :tag "At Point" at-point)
                 (const :tag "Bottom Left" bottom-left)
                 (const :tag "Top Left" top-left))
  :group 'org-footnote-preview)

(defcustom org-footnote-preview-delay 0.1
  "Delay in seconds before showing footnote preview."
  :type 'number
  :group 'org-footnote-preview)

(defcustom org-footnote-preview-show-with-cursor t
  "Show preview when cursor is on footnote reference."
  :type 'boolean
  :group 'org-footnote-preview)

(defcustom org-footnote-preview-show-with-mouse t
  "Show preview when mouse hovers over footnote reference."
  :type 'boolean
  :group 'org-footnote-preview)

;; Internal variables
(defvar org-footnote-preview-buffer "*org-footnote-preview*")
(defvar org-footnote-preview--frame nil)
(defvar org-footnote-preview--timer nil)
(defvar org-footnote-preview--bounds nil)
(defvar org-footnote-preview--last-point nil)
(defvar org-footnote-preview--mouse-timer nil)
(defvar org-footnote-preview--mouse-last-event nil)

(defconst org-footnote-preview--ignore-commands
  '(org-footnote-preview-hide
    org-footnote-preview-at-point
    org-footnote-preview--handle-mouse-movement
    keyboard-quit
    ignore
    handle-switch-frame
    mwheel-scroll)
  "Commands to ignore for automatic preview.")

(defface org-footnote-preview-background
  `((t :background ,(face-attribute 'tooltip :background nil t)
       :foreground ,(face-attribute 'tooltip :foreground nil t)))
  "Background face for footnote preview."
  :group 'org-footnote-preview)

(defface org-footnote-preview-border
  `((t :background ,(face-attribute 'shadow :foreground nil t)))
  "Border face for footnote preview."
  :group 'org-footnote-preview)

(defun org-footnote-preview--get-definition (label)
  "Get the footnote definition for LABEL."
  (save-excursion
    (goto-char (point-min))
    (when (re-search-forward
           (format "^\\[fn:%s\\]\\s-*\\(.*\\)" (regexp-quote label))
           nil t)
      (let ((start (match-beginning 1))
            (end (save-excursion
                   (if (re-search-forward "^\\[fn:" nil t)
                       (line-beginning-position)
                     (point-max)))))
        (string-trim (buffer-substring-no-properties start end))))))

(defun org-footnote-preview--get-definition-at-point ()
  "Get the footnote definition for the footnote at point."
  (when (org-in-regexp "\\[fn:\\([[:word:]_-]+\\)\\]")
    (let ((label (match-string 1))
          (bounds (cons (match-beginning 0) (match-end 0))))
      (setq org-footnote-preview--bounds bounds)
      (cons label (org-footnote-preview--get-definition label)))))

(defun org-footnote-preview--create-child-frame (buffer)
  "Create child frame for BUFFER."
  (let* ((parent-frame (selected-frame))
         (params `((parent-frame . ,parent-frame)
                   (name . "")
                   (no-accept-focus . t)
                   (min-width . 0)
                   (min-height . 0)
                   (border-width . 2)
                   (internal-border-width . 1)
                   (vertical-scroll-bars . nil)
                   (horizontal-scroll-bars . nil)
                   (left-fringe . 0)
                   (right-fringe . 0)
                   (menu-bar-lines . 0)
                   (tool-bar-lines . 0)
                   (tab-bar-lines . 0)
                   (mode-line-format . nil)  ; 隐藏 modeline
                   (header-line-format . nil)  ; 隐藏 header-line
                   (line-spacing . 0)
                   (unsplittable . t)
                   (no-other-frame . t)
                   (undecorated . t)
                   (cursor-type . nil)
                   (no-special-glyphs . t)
                   (desktop-dont-save . t)
                   ;; 设置精确的窗口边距
                   (left-margin-width . 0)
                   (right-margin-width . 0)
                   (scroll-margin . 0)
                   (background-color . ,(face-attribute 'org-footnote-preview-background :background nil t))
                   (foreground-color . ,(face-attribute 'org-footnote-preview-background :foreground nil t))))
         (window (display-buffer-in-child-frame buffer `((child-frame-parameters . ,params))))
         (frame (window-frame window)))
    (set-face-background 'internal-border
                         (face-attribute 'org-footnote-preview-border :background nil t)
                         frame)
    (when (facep 'child-frame-border)
      (set-face-background 'child-frame-border
                           (face-attribute 'org-footnote-preview-border :background nil t)
                           frame))
    (set-window-dedicated-p window t)
    ;; 完全隐藏各种格式行
    (with-current-buffer buffer
      (setq-local mode-line-format nil)
      (setq-local header-line-format nil)
      (setq-local tab-line-format nil)
      ;; 设置窗口边距为 0
      (setq-local left-margin-width 0)
      (setq-local right-margin-width 0)
      (setq-local scroll-margin 0)
      (setq-local scroll-conservatively 0))
    ;; 确保窗口边距设置生效
    (with-selected-window window
      (set-window-margins window 0 0)
      (set-window-scroll-bars window nil nil))
    frame))

(defun org-footnote-preview--calculate-position (frame)
  "Calculate position for FRAME exactly like lsp-ui-doc's at-point implementation."
  (let* ((edges (window-edges nil t nil t))
         (window-left (nth 0 edges))
         (window-top (nth 1 edges))
         (char-width (frame-char-width))
         (char-height (frame-char-height))
         (frame-width (frame-pixel-width frame))
         (frame-height (frame-pixel-height frame))
         ;; Get symbol position exactly like lsp-ui-doc
         (symbol-pos (or (and org-footnote-preview--bounds
                              (posn-x-y (posn-at-point (car org-footnote-preview--bounds))))
                         (posn-x-y (posn-at-point))))
         (x (car symbol-pos))
         (y (cdr symbol-pos))
         ;; Calculate frame position relative to screen (like lsp-ui-doc)
         ;; Key: offset by 2 char-widths to the right like lsp-ui-doc
         (frame-relative-symbol-x (+ window-left x (* char-width 2)))
         (frame-relative-symbol-y (+ window-top y))
         ;; Horizontal boundary checking (exactly like lsp-ui-doc)
         (frame-x (if (<= (frame-outer-width) (+ frame-relative-symbol-x frame-width))
                      ;; Would exceed right boundary, shift left
                      (- x (- (+ frame-relative-symbol-x frame-width)
                              (frame-outer-width)))
                    ;; Within bounds, use original position with 2-char offset
                    (+ x (* char-width 2))))
         ;; Vertical positioning strategy (exactly like lsp-ui-doc)
         (frame-y (if (<= frame-height frame-relative-symbol-y)
                      ;; Enough space above, show above the symbol
                      (- y frame-height)
                    ;; Not enough space above, show below
                    (+ y char-height))))
    ;; Return absolute screen coordinates
    (cons (+ window-left frame-x) (+ window-top frame-y))))

(defun org-footnote-preview--position-frame (frame)
  "Position FRAME appropriately."
  (when (frame-live-p frame)
    (let* ((window (frame-root-window frame))
           (text-size (window-text-pixel-size window nil nil 1000 1000 t))
           ;; 不需要额外的边距，因为我们已经隐藏了 modeline
           (width (+ (car text-size) (* (frame-char-width frame) 1)))
           ;; 精确的高度，不包含 modeline 空间
           (height (cdr text-size))
           (position (org-footnote-preview--calculate-position frame)))
      ;; 确保最小尺寸
      (setq width (max width (* (frame-char-width frame) 20)))
      (setq height (max height (frame-char-height frame)))
      ;; 设置精确的 frame 大小和位置
      (set-frame-size frame width height t)
      (set-frame-position frame (car position) (cdr position))
      (make-frame-visible frame)
      ;; 确保窗口完全适配内容
      (with-selected-frame frame
        (fit-window-to-buffer window height height width width)))))

(defun org-footnote-preview--display-childframe (content)
  "Display CONTENT using child-frame."
  (let ((buffer (get-buffer-create org-footnote-preview-buffer)))
    (with-current-buffer buffer
      (erase-buffer)
      (insert content)
      (org-mode)
      (goto-char (point-min))
      ;; 完全隐藏 modeline 和相关元素
      (setq-local mode-line-format nil)
      (setq-local header-line-format nil)
      (setq-local tab-line-format nil)
      ;; 禁用行号显示
      (setq-local display-line-numbers nil)
      (setq-local display-line-numbers-mode nil)
      (when (fboundp 'display-line-numbers-mode)
        (display-line-numbers-mode -1))
      ;; 移除多余的空行和空白
      (setq-local cursor-type nil)
      (setq-local show-trailing-whitespace nil)
      ;; 确保没有多余的空行
      (goto-char (point-max))
      (while (and (not (bobp)) (looking-back "\n\n+" nil))
        (delete-char -1))
      (when (fboundp 'org-modern-mode)
        (org-modern-mode 1)))
    (if (and org-footnote-preview--frame
             (frame-live-p org-footnote-preview--frame))
        (with-selected-window (frame-root-window org-footnote-preview--frame)
          (switch-to-buffer buffer))
      (setq org-footnote-preview--frame (org-footnote-preview--create-child-frame buffer)))
    (org-footnote-preview--position-frame org-footnote-preview--frame)))

(defun org-footnote-preview--display-posframe (content)
  "Display CONTENT using posframe."
  (with-current-buffer (get-buffer-create org-footnote-preview-buffer)
    (erase-buffer)
    (insert content)
    (org-mode)
    (goto-char (point-min))
    ;; 禁用行号显示
    (setq-local display-line-numbers nil)
    (setq-local display-line-numbers-mode nil)
    (when (fboundp 'display-line-numbers-mode)
      (display-line-numbers-mode -1)))
  (posframe-show
   org-footnote-preview-buffer
   :position (point)
   :poshandler (pcase org-footnote-preview-position
                 ('bottom-left 'posframe-poshandler-point-bottom-left-corner)
                 ('top-left 'posframe-poshandler-point-top-left-corner)
                 (_ 'posframe-poshandler-point-bottom-left-corner))
   :border-width 2
   :border-color (face-attribute 'org-footnote-preview-border :background nil t)
   :background-color (face-attribute 'org-footnote-preview-background :background nil t)
   :foreground-color (face-attribute 'org-footnote-preview-background :foreground nil t)
   :min-width 40
   :max-width 80
   :timeout 10))

(defun org-footnote-preview--display (content)
  "Display CONTENT in preview."
  (if (and org-footnote-preview-use-childframe
           (fboundp 'display-buffer-in-child-frame)
           (display-graphic-p))
      (org-footnote-preview--display-childframe content)
    (org-footnote-preview--display-posframe content)))

(defun org-footnote-preview-at-point ()
  "Show footnote definition at point."
  (interactive)
  (let ((definition-info (org-footnote-preview--get-definition-at-point)))
    (if definition-info
        (let ((content (cdr definition-info)))
          (if (and content (not (string-empty-p content)))
              (org-footnote-preview--display content)
            (message "Footnote definition is empty")))
      (message "No footnote at point"))))

(defun org-footnote-preview-hide ()
  "Hide footnote preview."
  (interactive)
  (when org-footnote-preview--timer
    (cancel-timer org-footnote-preview--timer)
    (setq org-footnote-preview--timer nil))
  (if org-footnote-preview-use-childframe
      (when (and org-footnote-preview--frame
                 (frame-live-p org-footnote-preview--frame))
        (delete-frame org-footnote-preview--frame)
        (setq org-footnote-preview--frame nil))
    (posframe-hide org-footnote-preview-buffer))
  (setq org-footnote-preview--bounds nil
        org-footnote-preview--last-point nil))

(defun org-footnote-preview--should-show-p ()
  "Return t if we should show preview."
  (and org-footnote-preview-show-with-cursor
       (not (minibufferp))
       (not (memq this-command org-footnote-preview--ignore-commands))
       (org-in-regexp "\\[fn:\\([[:word:]_-]+\\)\\]")))

(defun org-footnote-preview--auto-show ()
  "Automatically show preview if appropriate."
  (let ((current-point (point)))
    ;; 如果光标在脚注引用上，显示预览
    (if (org-in-regexp "\\[fn:\\([[:word:]_-]+\\)\\]")
        (let ((definition-info (org-footnote-preview--get-definition-at-point)))
          (when (and definition-info (cdr definition-info)
                     (not (string-empty-p (cdr definition-info))))
            ;; 只有在位置改变时才重新显示，避免闪烁
            (unless (equal current-point org-footnote-preview--last-point)
              (org-footnote-preview--display (cdr definition-info))
              (setq org-footnote-preview--last-point current-point))))
      ;; 不在脚注引用上，隐藏预览
      (when org-footnote-preview--last-point
        (org-footnote-preview-hide)
        (setq org-footnote-preview--last-point nil)))))

(defun org-footnote-preview--make-request ()
  "Make request for footnote preview."
  ;; Setup mouse tracking like lsp-ui-doc
  (and (not track-mouse) org-footnote-preview-show-with-mouse (setq-local track-mouse t))

  (when (and org-footnote-preview-show-with-cursor
             (not (minibufferp))
             (not (memq this-command org-footnote-preview--ignore-commands)))
    (when org-footnote-preview--timer
      (cancel-timer org-footnote-preview--timer))
    ;; 更短的延迟，更快响应
    (setq org-footnote-preview--timer
          (run-with-idle-timer 0.1 nil #'org-footnote-preview--auto-show))))

;; Mouse support functions - 基于 lsp-ui-doc 的实现
(defun org-footnote-preview--handle-mouse-movement (event)
  "Handle mouse movement EVENT for footnote preview."
  (interactive "e")
  (when org-footnote-preview-show-with-mouse
    (when org-footnote-preview--mouse-timer
      (cancel-timer org-footnote-preview--mouse-timer))
    (let* ((e (cadr event))
           (point (posn-point e))
           (same-win (eq (selected-window) (posn-window e))))
      ;; Hide if mouse moved away from footnote
      (and org-footnote-preview--bounds
           point
           (or (< point (car org-footnote-preview--bounds))
               (> point (cdr org-footnote-preview--bounds))
               (not same-win))
           (org-footnote-preview-hide))
      ;; Show if mouse is on footnote in same window
      (when (and same-win point)
        (setq org-footnote-preview--mouse-last-event point
              org-footnote-preview--mouse-timer
              (run-with-idle-timer 0.2 nil #'org-footnote-preview--mouse-display))))))

(defun org-footnote-preview--mouse-display ()
  "Display footnote preview at mouse position."
  (when (and org-footnote-preview--mouse-last-event
             org-footnote-preview-show-with-mouse)
    (save-excursion
      (goto-char org-footnote-preview--mouse-last-event)
      (when (org-in-regexp "\\[fn:\\([[:word:]_-]+\\)\\]")
        (let ((definition-info (org-footnote-preview--get-definition-at-point)))
          (when (and definition-info (cdr definition-info)
                     (not (string-empty-p (cdr definition-info))))
            (org-footnote-preview--display (cdr definition-info))))))))

(defun org-footnote-preview--setup-mouse ()
  "Setup mouse tracking for footnote preview."
  (when org-footnote-preview-show-with-mouse
    ;; Use keymap binding like lsp-ui-doc, not hook
    (local-set-key (kbd "<mouse-movement>") #'org-footnote-preview--handle-mouse-movement)
    (setq-local track-mouse t)))

;; Enhanced keybindings
(map! :map org-mode-map
      :desc "Preview footnote" "C-c f p" #'org-footnote-preview-at-point
      :desc "Hide footnote preview" "C-c f h" #'org-footnote-preview-hide
      :desc "Preview footnote at point" "C-c C-d" #'org-footnote-preview-at-point)

;; Auto-preview mode
(define-minor-mode org-footnote-preview-mode
  "Minor mode for automatic footnote preview."
  :lighter " FnPrev"
  :group 'org-footnote-preview
  (if org-footnote-preview-mode
      (progn
        (add-hook 'post-command-hook #'org-footnote-preview--make-request nil t)
        (add-hook 'window-scroll-functions
                  (lambda (&rest _) (org-footnote-preview-hide)) nil t)
        (org-footnote-preview--setup-mouse))
    (remove-hook 'post-command-hook #'org-footnote-preview--make-request t)
    (remove-hook 'window-scroll-functions
                 (lambda (&rest _) (org-footnote-preview-hide)) t)
    ;; Clean up mouse binding
    (when org-footnote-preview-show-with-mouse
      (local-unset-key (kbd "<mouse-movement>")))
    (when org-footnote-preview--timer
      (cancel-timer org-footnote-preview--timer)
      (setq org-footnote-preview--timer nil))
    (when org-footnote-preview--mouse-timer
      (cancel-timer org-footnote-preview--mouse-timer)
      (setq org-footnote-preview--mouse-timer nil))
    (org-footnote-preview-hide)))

;; Auto-enable in org-mode
(add-hook 'org-mode-hook #'org-footnote-preview-mode)
#+end_src
